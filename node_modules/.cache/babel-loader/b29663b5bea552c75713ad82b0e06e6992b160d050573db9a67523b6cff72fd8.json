{"ast":null,"code":"/**\n * @module ol/format/GML2\n */\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport { OBJECT_PROPERTY_NODE_FACTORY, createElementNS, getAllTextContent, makeArrayPusher, makeChildAppender, makeReplacer, makeSimpleNodeFactory, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\nimport { createOrUpdate } from '../extent.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\nimport { writeStringTextNode } from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation = GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(this.readFeaturesInternal);\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */\n    objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop([null], this.BOX_PARSERS_, node, objectStack, this);\n    return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[1][3], flatCoordinates[1][4]);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array<Array<number>>} */\n      objectStack[objectStack.length - 1];\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array<Array<number>>} */\n      objectStack[objectStack.length - 1];\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */value.getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */fid);\n    }\n    const context = /** @type {Object} */objectStack[objectStack.length - 1];\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (key == geometryName || typeof ( /** @type {?} */value.getSimplifiedGeometry) === 'function') {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, context.serializers, makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName,\n      curve: curve\n    }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */\n    objectStack[objectStack.length - 1];\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions( /** @type {import(\"../extent.js\").Extent} */geometry, context);\n    } else {\n      value = transformGeometryWithOptions( /** @type {import(\"../geom/Geometry.js\").default} */geometry, true, context);\n    }\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop({\n        node: node,\n        hasZ: hasZ,\n        srsName: srsName\n      }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs');\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ',' + point[1] : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName\n    }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory('pointMember'), points, objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName,\n      surface: surface\n    }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    {\n      node: node\n    }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS('http://www.opengis.net/gml', MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(GML2.prototype.writeMultiSurfaceOrPolygon),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(GML2.prototype.writeLineStringOrCurveMember),\n    'curveMember': makeChildAppender(GML2.prototype.writeLineStringOrCurveMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember),\n    'polygonMember': makeChildAppender(GML2.prototype.writeSurfaceOrPolygonMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\nexport default GML2;","map":{"version":3,"names":["GMLBase","GMLNS","OBJECT_PROPERTY_NODE_FACTORY","createElementNS","getAllTextContent","makeArrayPusher","makeChildAppender","makeReplacer","makeSimpleNodeFactory","pushParseAndPop","pushSerializeAndPop","createOrUpdate","get","getProjection","transformExtentWithOptions","transformGeometryWithOptions","writeStringTextNode","schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML2","constructor","options","FEATURE_COLLECTION_PARSERS","readFeaturesInternal","readFlatCoordinates","node","objectStack","s","replace","context","containerSrs","axisOrientation","proj","getAxisOrientation","coordsGroups","trim","split","flatCoordinates","i","ii","length","coords","x","parseFloat","y","z","substr","push","readBox","BOX_PARSERS_","innerBoundaryIsParser","flatLinearRing","undefined","RING_PARSERS","flatLinearRings","outerBoundaryIsParser","GEOMETRY_NODE_FACTORY_","value","nodeName","multiSurface","surface","multiCurve","Array","isArray","getType","writeFeatureElement","feature","fid","getId","setAttribute","featureNS","geometryName","getGeometryName","serializers","keys","values","hasProperties","properties","getProperties","key","getSimplifiedGeometry","writeGeometryElement","item","Object","assign","writeCurveOrLineString","geometry","srsName","coordinates","createCoordinatesNode_","namespaceURI","appendChild","writeCoordinates_","segments","writeCurveSegments_","writeLineStringOrCurveMember","line","child","writeMultiCurveOrLineString","hasZ","curve","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","GEOMETRY_SERIALIZERS","points","getCoordinates","len","parts","point","getCoords_","join","writeSurfaceOrPolygon","rings","getLinearRings","RING_SERIALIZERS","RING_NODE_FACTORY_","patches","writeSurfacePatches_","parentNode","exteriorWritten","polygon","writeRing","ring","linearRing","writeLinearRing","writePoint","coord","writeMultiPoint","getPoints","POINTMEMBER_SERIALIZERS","writePointMember","writeMultiSurfaceOrPolygon","polygons","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS","writeSurfaceOrPolygonMember","writeEnvelope","extent","ENVELOPE_SERIALIZERS","prototype","GEOMETRY_FLAT_COORDINATES_PARSERS","FLAT_LINEAR_RINGS_PARSERS","GEOMETRY_PARSERS","readPoint","readMultiPoint","readLineString","readMultiLineString","readLinearRing","readPolygon","readMultiPolygon"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/GML2.js"],"sourcesContent":["/**\n * @module ol/format/GML2\n */\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\nimport {writeStringTextNode} from './xsd.js';\n\n/**\n * @const\n * @type {string}\n */\nconst schemaLocation =\n  GMLNS + ' http://schemas.opengis.net/gml/2.1.2/feature.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format,\n * version 2.1.2.\n *\n * @api\n */\nclass GML2 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    this.FEATURE_COLLECTION_PARSERS[GMLNS]['featureMember'] = makeArrayPusher(\n      this.readFeaturesInternal,\n    );\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatCoordinates(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n      objectStack[0]\n    );\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      if (proj) {\n        axisOrientation = proj.getAxisOrientation();\n      }\n    }\n    const coordsGroups = s.trim().split(/\\s+/);\n    const flatCoordinates = [];\n    for (let i = 0, ii = coordsGroups.length; i < ii; i++) {\n      const coords = coordsGroups[i].split(/,+/);\n      const x = parseFloat(coords[0]);\n      const y = parseFloat(coords[1]);\n      const z = coords.length === 3 ? parseFloat(coords[2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readBox(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.BOX_PARSERS_,\n      node,\n      objectStack,\n      this,\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[1][3],\n      flatCoordinates[1][4],\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  innerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  outerBoundaryIsParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS('http://www.opengis.net/gml', nodeName);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this,\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n      node.appendChild(coordinates);\n      this.writeCoordinates_(coordinates, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiLineString.js\").default} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context,\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context,\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {string} namespaceURI XML namespace.\n   * @return {Element} coordinates node.\n   * @private\n   */\n  createCoordinatesNode_(namespaceURI) {\n    const coordinates = createElementNS(namespaceURI, 'coordinates');\n    coordinates.setAttribute('decimal', '.');\n    coordinates.setAttribute('cs', ',');\n    coordinates.setAttribute('ts', ' ');\n\n    return coordinates;\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LineString.js\").default|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCoordinates_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    for (let i = 0; i < len; ++i) {\n      const point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LineString.js\").default} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this,\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'innerBoundaryIs' : 'outerBoundaryIs',\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ',' + point[1]\n        : point[1] + ',' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ',' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    const point = geometry.getCoordinates();\n    const coord = this.getCoords_(point, srsName, hasZ);\n    writeStringTextNode(coordinates, coord);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const coordinates = this.createCoordinatesNode_(node.namespaceURI);\n    node.appendChild(coordinates);\n    this.writeCoordinates_(coordinates, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPolygon.js\").default} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Polygon.js\").default} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this,\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      'http://www.opengis.net/gml',\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName],\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'innerBoundaryIs': GML2.prototype.innerBoundaryIsParser,\n    'outerBoundaryIs': GML2.prototype.outerBoundaryIsParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.BOX_PARSERS_ = {\n  'http://www.opengis.net/gml': {\n    'coordinates': makeArrayPusher(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML2.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Box': makeReplacer(GML2.prototype.readBox),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML2.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML2.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML2.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML2.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML2.prototype.writeMultiCurveOrLineString,\n    ),\n    'LinearRing': makeChildAppender(GML2.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Surface': makeChildAppender(GML2.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML2.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Envelope': makeChildAppender(GML2.prototype.writeEnvelope),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n    'curveMember': makeChildAppender(\n      GML2.prototype.writeLineStringOrCurveMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'outerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n    'innerBoundaryIs': makeChildAppender(GML2.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML2.prototype.writePointMember),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n    'polygonMember': makeChildAppender(\n      GML2.prototype.writeSurfaceOrPolygonMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML2.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\nexport default GML2;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}