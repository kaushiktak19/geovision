{"ast":null,"code":"/**\n * @module ol/format/xsd\n */\nimport { getAllTextContent, getDocument } from '../xml.js';\nimport { padNumber } from '../string.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string = date.getUTCFullYear() + '-' + padNumber(date.getUTCMonth() + 1, 2) + '-' + padNumber(date.getUTCDate(), 2) + 'T' + padNumber(date.getUTCHours(), 2) + ':' + padNumber(date.getUTCMinutes(), 2) + ':' + padNumber(date.getUTCSeconds(), 2) + 'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}","map":{"version":3,"names":["getAllTextContent","getDocument","padNumber","readBoolean","node","s","readBooleanString","string","m","exec","undefined","readDateTime","dateTime","Date","parse","isNaN","readDecimal","readDecimalString","parseFloat","readPositiveInteger","readNonNegativeIntegerString","parseInt","readString","trim","writeBooleanTextNode","bool","writeStringTextNode","writeCDATASection","appendChild","createCDATASection","writeDateTimeTextNode","date","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","createTextNode","writeDecimalTextNode","decimal","toPrecision","writeNonNegativeIntegerTextNode","nonNegativeInteger","toString"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/xsd.js"],"sourcesContent":["/**\n * @module ol/format/xsd\n */\nimport {getAllTextContent, getDocument} from '../xml.js';\nimport {padNumber} from '../string.js';\n\n/**\n * @param {Node} node Node.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBoolean(node) {\n  const s = getAllTextContent(node, false);\n  return readBooleanString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {boolean|undefined} Boolean.\n */\nexport function readBooleanString(string) {\n  const m = /^\\s*(true|1)|(false|0)\\s*$/.exec(string);\n  if (m) {\n    return m[1] !== undefined || false;\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} DateTime in seconds.\n */\nexport function readDateTime(node) {\n  const s = getAllTextContent(node, false);\n  const dateTime = Date.parse(s);\n  return isNaN(dateTime) ? undefined : dateTime / 1000;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimal(node) {\n  const s = getAllTextContent(node, false);\n  return readDecimalString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Decimal.\n */\nexport function readDecimalString(string) {\n  // FIXME check spec\n  const m = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)\\s*$/i.exec(string);\n  if (m) {\n    return parseFloat(m[1]);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Non negative integer.\n */\nexport function readPositiveInteger(node) {\n  const s = getAllTextContent(node, false);\n  return readNonNegativeIntegerString(s);\n}\n\n/**\n * @param {string} string String.\n * @return {number|undefined} Non negative integer.\n */\nexport function readNonNegativeIntegerString(string) {\n  const m = /^\\s*(\\d+)\\s*$/.exec(string);\n  if (m) {\n    return parseInt(m[1], 10);\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string|undefined} String.\n */\nexport function readString(node) {\n  return getAllTextContent(node, false).trim();\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the boolean to.\n * @param {boolean} bool Boolean.\n */\nexport function writeBooleanTextNode(node, bool) {\n  writeStringTextNode(node, bool ? '1' : '0');\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the string to.\n * @param {string} string String.\n */\nexport function writeCDATASection(node, string) {\n  node.appendChild(getDocument().createCDATASection(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the dateTime to.\n * @param {number} dateTime DateTime in seconds.\n */\nexport function writeDateTimeTextNode(node, dateTime) {\n  const date = new Date(dateTime * 1000);\n  const string =\n    date.getUTCFullYear() +\n    '-' +\n    padNumber(date.getUTCMonth() + 1, 2) +\n    '-' +\n    padNumber(date.getUTCDate(), 2) +\n    'T' +\n    padNumber(date.getUTCHours(), 2) +\n    ':' +\n    padNumber(date.getUTCMinutes(), 2) +\n    ':' +\n    padNumber(date.getUTCSeconds(), 2) +\n    'Z';\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} decimal Decimal.\n */\nexport function writeDecimalTextNode(node, decimal) {\n  const string = decimal.toPrecision();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the decimal to.\n * @param {number} nonNegativeInteger Non negative integer.\n */\nexport function writeNonNegativeIntegerTextNode(node, nonNegativeInteger) {\n  const string = nonNegativeInteger.toString();\n  node.appendChild(getDocument().createTextNode(string));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the string to.\n * @param {string} string String.\n */\nexport function writeStringTextNode(node, string) {\n  node.appendChild(getDocument().createTextNode(string));\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAAQA,iBAAiB,EAAEC,WAAW,QAAO,WAAW;AACxD,SAAQC,SAAS,QAAO,cAAc;;AAEtC;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAWA,CAACC,IAAI,EAAE;EAChC,MAAMC,CAAC,GAAGL,iBAAiB,CAACI,IAAI,EAAE,KAAK,CAAC;EACxC,OAAOE,iBAAiB,CAACD,CAAC,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,iBAAiBA,CAACC,MAAM,EAAE;EACxC,MAAMC,CAAC,GAAG,4BAA4B,CAACC,IAAI,CAACF,MAAM,CAAC;EACnD,IAAIC,CAAC,EAAE;IACL,OAAOA,CAAC,CAAC,CAAC,CAAC,KAAKE,SAAS,IAAI,KAAK;EACpC;EACA,OAAOA,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,YAAYA,CAACP,IAAI,EAAE;EACjC,MAAMC,CAAC,GAAGL,iBAAiB,CAACI,IAAI,EAAE,KAAK,CAAC;EACxC,MAAMQ,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACT,CAAC,CAAC;EAC9B,OAAOU,KAAK,CAACH,QAAQ,CAAC,GAAGF,SAAS,GAAGE,QAAQ,GAAG,IAAI;AACtD;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASI,WAAWA,CAACZ,IAAI,EAAE;EAChC,MAAMC,CAAC,GAAGL,iBAAiB,CAACI,IAAI,EAAE,KAAK,CAAC;EACxC,OAAOa,iBAAiB,CAACZ,CAAC,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASY,iBAAiBA,CAACV,MAAM,EAAE;EACxC;EACA,MAAMC,CAAC,GAAG,2CAA2C,CAACC,IAAI,CAACF,MAAM,CAAC;EAClE,IAAIC,CAAC,EAAE;IACL,OAAOU,UAAU,CAACV,CAAC,CAAC,CAAC,CAAC,CAAC;EACzB;EACA,OAAOE,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASS,mBAAmBA,CAACf,IAAI,EAAE;EACxC,MAAMC,CAAC,GAAGL,iBAAiB,CAACI,IAAI,EAAE,KAAK,CAAC;EACxC,OAAOgB,4BAA4B,CAACf,CAAC,CAAC;AACxC;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASe,4BAA4BA,CAACb,MAAM,EAAE;EACnD,MAAMC,CAAC,GAAG,eAAe,CAACC,IAAI,CAACF,MAAM,CAAC;EACtC,IAAIC,CAAC,EAAE;IACL,OAAOa,QAAQ,CAACb,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;EAC3B;EACA,OAAOE,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASY,UAAUA,CAAClB,IAAI,EAAE;EAC/B,OAAOJ,iBAAiB,CAACI,IAAI,EAAE,KAAK,CAAC,CAACmB,IAAI,CAAC,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACpB,IAAI,EAAEqB,IAAI,EAAE;EAC/CC,mBAAmB,CAACtB,IAAI,EAAEqB,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;AAC7C;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASE,iBAAiBA,CAACvB,IAAI,EAAEG,MAAM,EAAE;EAC9CH,IAAI,CAACwB,WAAW,CAAC3B,WAAW,CAAC,CAAC,CAAC4B,kBAAkB,CAACtB,MAAM,CAAC,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASuB,qBAAqBA,CAAC1B,IAAI,EAAEQ,QAAQ,EAAE;EACpD,MAAMmB,IAAI,GAAG,IAAIlB,IAAI,CAACD,QAAQ,GAAG,IAAI,CAAC;EACtC,MAAML,MAAM,GACVwB,IAAI,CAACC,cAAc,CAAC,CAAC,GACrB,GAAG,GACH9B,SAAS,CAAC6B,IAAI,CAACE,WAAW,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,GACpC,GAAG,GACH/B,SAAS,CAAC6B,IAAI,CAACG,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC,GAC/B,GAAG,GACHhC,SAAS,CAAC6B,IAAI,CAACI,WAAW,CAAC,CAAC,EAAE,CAAC,CAAC,GAChC,GAAG,GACHjC,SAAS,CAAC6B,IAAI,CAACK,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,GAClC,GAAG,GACHlC,SAAS,CAAC6B,IAAI,CAACM,aAAa,CAAC,CAAC,EAAE,CAAC,CAAC,GAClC,GAAG;EACLjC,IAAI,CAACwB,WAAW,CAAC3B,WAAW,CAAC,CAAC,CAACqC,cAAc,CAAC/B,MAAM,CAAC,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASgC,oBAAoBA,CAACnC,IAAI,EAAEoC,OAAO,EAAE;EAClD,MAAMjC,MAAM,GAAGiC,OAAO,CAACC,WAAW,CAAC,CAAC;EACpCrC,IAAI,CAACwB,WAAW,CAAC3B,WAAW,CAAC,CAAC,CAACqC,cAAc,CAAC/B,MAAM,CAAC,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASmC,+BAA+BA,CAACtC,IAAI,EAAEuC,kBAAkB,EAAE;EACxE,MAAMpC,MAAM,GAAGoC,kBAAkB,CAACC,QAAQ,CAAC,CAAC;EAC5CxC,IAAI,CAACwB,WAAW,CAAC3B,WAAW,CAAC,CAAC,CAACqC,cAAc,CAAC/B,MAAM,CAAC,CAAC;AACxD;;AAEA;AACA;AACA;AACA;AACA,OAAO,SAASmB,mBAAmBA,CAACtB,IAAI,EAAEG,MAAM,EAAE;EAChDH,IAAI,CAACwB,WAAW,CAAC3B,WAAW,CAAC,CAAC,CAACqC,cAAc,CAAC/B,MAAM,CAAC,CAAC;AACxD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}