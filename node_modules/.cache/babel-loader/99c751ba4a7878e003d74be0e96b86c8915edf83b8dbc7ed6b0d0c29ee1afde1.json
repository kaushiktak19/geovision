{"ast":null,"code":"/**\n * @module ol/format/KML\n */\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport Icon from '../style/Icon.js';\nimport ImageState from '../ImageState.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport XMLFeature from './XMLFeature.js';\nimport { OBJECT_PROPERTY_NODE_FACTORY, XML_SCHEMA_INSTANCE_URI, createElementNS, getAllTextContent, isDocument, makeArrayExtender, makeArrayPusher, makeChildAppender, makeObjectPropertySetter, makeReplacer, makeSequence, makeSimpleNodeFactory, makeStructureNS, parse, parseNode, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\nimport { asArray } from '../color.js';\nimport { extend } from '../array.js';\nimport { get as getProjection } from '../proj.js';\nimport { readBoolean, readDecimal, readString, writeBooleanTextNode, writeCDATASection, writeDecimalTextNode, writeStringTextNode } from './xsd.js';\nimport { toRadians } from '../math.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {Object} Vec2\n * @property {number} x X coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\n * @property {number} y Y coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\n */\n\n/**\n * @typedef {Object} GxTrackObject\n * @property {Array<Array<number>>} coordinates Coordinates.\n * @property {Array<number>} whens Whens.\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [null, 'http://earth.google.com/kml/2.0', 'http://earth.google.com/kml/2.1', 'http://earth.google.com/kml/2.2', 'http://www.opengis.net/kml/2.2'];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION = 'http://www.opengis.net/kml/2.2 ' + 'https://developers.google.com/kml/schema/kml22gx.xsd';\n\n/**\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\n */\nconst ICON_ANCHOR_UNITS_MAP = {\n  'fraction': 'fraction',\n  'pixels': 'pixels',\n  'insetPixels': 'pixels'\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PLACEMARK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\n  'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\n  'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\n  'Point': makeObjectPropertySetter(readPoint, 'geometry'),\n  'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\n  'Style': makeObjectPropertySetter(readStyle),\n  'StyleMap': placemarkStyleMapParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\n  'visibility': makeObjectPropertySetter(readBoolean)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\n  'Track': makeObjectPropertySetter(readGxTrack, 'geometry')\n}));\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'Link': linkParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'visibility': makeObjectPropertySetter(readBoolean)\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI)\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CAMERA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  Altitude: makeObjectPropertySetter(readDecimal),\n  Longitude: makeObjectPropertySetter(readDecimal),\n  Latitude: makeObjectPropertySetter(readDecimal),\n  Tilt: makeObjectPropertySetter(readDecimal),\n  AltitudeMode: makeObjectPropertySetter(readString),\n  Heading: makeObjectPropertySetter(readDecimal),\n  Roll: makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LatLonAltBox': latLonAltBoxParser,\n  'Lod': lodParser\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Document': makeChildAppender(writeDocument),\n  'Placemark': makeChildAppender(writePlacemark)\n});\n\n/**\n * @type {import(\"../color.js\").Color}\n */\nlet DEFAULT_COLOR;\n\n/**\n * @type {Fill|null}\n */\nlet DEFAULT_FILL_STYLE = null;\n\n/**\n * Get the default fill style (or null if not yet set).\n * @return {Fill|null} The default fill style.\n */\nexport function getDefaultFillStyle() {\n  return DEFAULT_FILL_STYLE;\n}\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_SIZE;\n\n/**\n * @type {string}\n */\nlet DEFAULT_IMAGE_STYLE_SRC;\n\n/**\n * @type {import(\"../style/Image.js\").default|null}\n */\nlet DEFAULT_IMAGE_STYLE = null;\n\n/**\n * Get the default image style (or null if not yet set).\n * @return {import(\"../style/Image.js\").default|null} The default image style.\n */\nexport function getDefaultImageStyle() {\n  return DEFAULT_IMAGE_STYLE;\n}\n\n/**\n * @type {string}\n */\nlet DEFAULT_NO_IMAGE_STYLE;\n\n/**\n * @type {Stroke|null}\n */\nlet DEFAULT_STROKE_STYLE = null;\n\n/**\n * Get the default stroke style (or null if not yet set).\n * @return {Stroke|null} The default stroke style.\n */\nexport function getDefaultStrokeStyle() {\n  return DEFAULT_STROKE_STYLE;\n}\n\n/**\n * @type {Stroke}\n */\nlet DEFAULT_TEXT_STROKE_STYLE;\n\n/**\n * @type {Text|null}\n */\nlet DEFAULT_TEXT_STYLE = null;\n\n/**\n * Get the default text style (or null if not yet set).\n * @return {Text|null} The default text style.\n */\nexport function getDefaultTextStyle() {\n  return DEFAULT_TEXT_STYLE;\n}\n\n/**\n * @type {Style|null}\n */\nlet DEFAULT_STYLE = null;\n\n/**\n * Get the default style (or null if not yet set).\n * @return {Style|null} The default style.\n */\nexport function getDefaultStyle() {\n  return DEFAULT_STYLE;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet DEFAULT_STYLE_ARRAY = null;\n\n/**\n * Get the default style array (or null if not yet set).\n * @return {Array<Style>|null} The default style.\n */\nexport function getDefaultStyleArray() {\n  return DEFAULT_STYLE_ARRAY;\n}\n\n/**\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\n * @param {import(\"../size.js\").Size} size Image size.\n * @return {number} Scale.\n */\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n  DEFAULT_FILL_STYLE = new Fill({\n    color: DEFAULT_COLOR\n  });\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n  DEFAULT_IMAGE_STYLE_SRC = 'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n  DEFAULT_IMAGE_STYLE = new Icon({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: 'bottom-left',\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: 'anonymous',\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC\n  });\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\n  DEFAULT_STROKE_STYLE = new Stroke({\n    color: DEFAULT_COLOR,\n    width: 1\n  });\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\n    color: [51, 51, 51, 1],\n    width: 2\n  });\n  DEFAULT_TEXT_STYLE = new Text({\n    font: 'bold 16px Helvetica',\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8\n  });\n  DEFAULT_STYLE = new Style({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0\n  });\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\n\n/**\n * @type {HTMLTextAreaElement}\n */\nlet TEXTAREA;\n\n/**\n * A function that takes a url `{string}` and returns a url `{string}`.\n * Might be used to change an icon path or to substitute a\n * data url obtained from a KMZ array buffer.\n *\n * @typedef {function(string):string} IconUrlFunction\n * @api\n */\n\n/**\n * Function that returns a url unchanged.\n * @param {string} href Input url.\n * @return {string} Output url.\n */\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\n * @property {Array<Style>} [defaultStyle] Default style. The\n * default default style is the same as Google Earth.\n * @property {boolean} [writeStyles=true] Write styles into KML.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the KML format.\n *\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\n * a KML source.\n *\n * MultiGeometries are converted into GeometryCollections if they are a mix of\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\n * all of the same type.\n *\n * @api\n */\nclass KML extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {Array<Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle ? options.defaultStyle : DEFAULT_STYLE_ARRAY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ = options.extractStyles !== undefined ? options.extractStyles : true;\n\n    /**\n     * @type {boolean}\n     */\n    this.writeStyles_ = options.writeStyles !== undefined ? options.writeStyles : true;\n\n    /**\n     * @private\n     * @type {!Object<string, (Array<Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ = options.showPointNames !== undefined ? options.showPointNames : true;\n\n    /**\n     * @type {null|string}\n     */\n    this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    /**\n     * @type {IconUrlFunction}\n     */\n    this.iconUrlFunction_ = options.iconUrlFunction ? options.iconUrlFunction : defaultIconUrlFunction;\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<Feature>|undefined} Features.\n   */\n  readDocumentOrFolder_(node, objectStack) {\n    // FIXME use scope somehow\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\n      'Style': this.readSharedStyle_.bind(this),\n      'StyleMap': this.readSharedStyleMap_.bind(this)\n    });\n    /** @type {Array<Feature>} */\n    // @ts-ignore\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Feature|undefined} Feature.\n   */\n  readPlacemark_(node, objectStack) {\n    const object = pushParseAndPop({\n      'geometry': null\n    }, PLACEMARK_PARSERS, node, objectStack, this);\n    if (!object) {\n      return undefined;\n    }\n    const feature = new Feature();\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */\n    objectStack[0];\n    const geometry = object['geometry'];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n    if (this.extractStyles_) {\n      const style = object['Style'];\n      const styleUrl = object['styleUrl'];\n      const styleFunction = createFeatureStyleFunction(style, styleUrl, this.defaultStyle_, this.sharedStyles_, this.showPointNames_);\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n\n    feature.setProperties(object, true);\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyle_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      const style = readStyle.call(this, node, objectStack);\n      if (style) {\n        let styleUri;\n        let baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          const url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyleMap_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    let styleUri;\n    let baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      const url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return null;\n    }\n    const feature = this.readPlacemark_(node, [this.getReadOptions(node, options)]);\n    if (feature) {\n      return feature;\n    }\n    return null;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return [];\n    }\n    let features;\n    const localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(node, [this.getReadOptions(node, options)]);\n      if (features) {\n        return features;\n      }\n      return [];\n    }\n    if (localName == 'Placemark') {\n      const feature = this.readPlacemark_(node, [this.getReadOptions(node, options)]);\n      if (feature) {\n        return [feature];\n      }\n      return [];\n    }\n    if (localName == 'kml') {\n      features = [];\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        const fs = this.readFeaturesFromNode(n, options);\n        if (fs) {\n          extend(features, fs);\n        }\n      }\n      return features;\n    }\n    return [];\n  }\n\n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  readName(source) {\n    if (!source) {\n      return undefined;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readNameFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readNameFromDocument( /** @type {Document} */source);\n    }\n    return this.readNameFromNode( /** @type {Element} */source);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  readNameFromDocument(doc) {\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        const name = this.readNameFromNode( /** @type {Element} */n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {string|undefined} Name.\n   */\n  readNameFromNode(node) {\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\n        return readString(n);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'Placemark' || localName == 'kml')) {\n        const name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Network links.\n   * @api\n   */\n  readNetworkLinks(source) {\n    const networkLinks = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(networkLinks, this.readNetworkLinksFromDocument( /** @type {Document} */source));\n    } else {\n      extend(networkLinks, this.readNetworkLinksFromNode( /** @type {Element} */source));\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromDocument(doc) {\n    const networkLinks = [];\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(networkLinks, this.readNetworkLinksFromNode( /** @type {Element} */n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromNode(node) {\n    const networkLinks = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'NetworkLink') {\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Regions.\n   * @api\n   */\n  readRegion(source) {\n    const regions = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(regions, this.readRegionFromDocument( /** @type {Document} */source));\n    } else {\n      extend(regions, this.readRegionFromNode( /** @type {Element} */source));\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Region.\n   */\n  readRegionFromDocument(doc) {\n    const regions = [];\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(regions, this.readRegionFromNode( /** @type {Element} */n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Region.\n   * @api\n   */\n  readRegionFromNode(node) {\n    const regions = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\n        regions.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName == 'Document' || localName == 'Folder' || localName == 'kml')) {\n        extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.\n   * @property {number} [Latitude] Latitude of the camera.\n   * @property {number} [Longitude] Longitude of the camera.\n   * @property {number} [Altitude] Altitude of the camera.\n   * @property {string} [AltitudeMode] Floor-related altitude mode.\n   * @property {number} [Heading] Horizontal camera rotation.\n   * @property {number} [Tilt] Lateral camera rotation.\n   * @property {number} [Roll] Vertical camera rotation.\n   */\n\n  /**\n   * Read the cameras of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<KMLCamera>} Cameras.\n   * @api\n   */\n  readCamera(source) {\n    const cameras = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(cameras, this.readCameraFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(cameras, this.readCameraFromDocument( /** @type {Document} */source));\n    } else {\n      extend(cameras, this.readCameraFromNode( /** @type {Element} */source));\n    }\n    return cameras;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<KMLCamera>} Cameras.\n   */\n  readCameraFromDocument(doc) {\n    const cameras = [];\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType === Node.ELEMENT_NODE) {\n        extend(cameras, this.readCameraFromNode( /** @type {Element} */n));\n      }\n    }\n    return cameras;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<KMLCamera>} Cameras.\n   * @api\n   */\n  readCameraFromNode(node) {\n    const cameras = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName === 'Camera') {\n        const obj = pushParseAndPop({}, CAMERA_PARSERS, n, []);\n        cameras.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && (localName === 'Document' || localName === 'Folder' || localName === 'Placemark' || localName === 'kml')) {\n        extend(cameras, this.readCameraFromNode(n));\n      }\n    }\n    return cameras;\n  }\n\n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATION);\n    const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n      node: kml\n    };\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\n    const properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    const values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(context, KML_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, [options], orderedKeys, this);\n    return kml;\n  }\n}\n\n/**\n * @param {Style|undefined} foundStyle Style.\n * @param {string} name Name.\n * @return {Style} style Style.\n */\nfunction createNameStyleFunction(foundStyle, name) {\n  const textOffset = [0, 0];\n  /** @type {CanvasTextAlign} */\n  let textAlign = 'start';\n  const imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    const imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      const imageScale = imageStyle.getScaleArray();\n      const anchor = imageStyle.getAnchor();\n      // Offset the label to be centered to the right of the icon,\n      // if there is one.\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign = 'left';\n    }\n  }\n  let textStyle = foundStyle.getText();\n  if (textStyle) {\n    // clone the text style, customizing it with name, alignments and offset.\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign);\n  const nameStyle = new Style({\n    image: imageStyle,\n    text: textStyle\n  });\n  return nameStyle;\n}\n\n/**\n * @param {Array<Style>|undefined} style Style.\n * @param {string} styleUrl Style URL.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\n */\nfunction createFeatureStyleFunction(style, styleUrl, defaultStyle, sharedStyles, showPointNames) {\n  return (\n    /**\n     * @param {Feature} feature feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>|Style} Style.\n     */\n    function (feature, resolution) {\n      let drawName = showPointNames;\n      let name = '';\n      let multiGeometryPoints = [];\n      if (drawName) {\n        const geometry = feature.getGeometry();\n        if (geometry) {\n          if (geometry instanceof GeometryCollection) {\n            multiGeometryPoints = geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n              const type = geometry.getType();\n              return type === 'Point' || type === 'MultiPoint';\n            });\n            drawName = multiGeometryPoints.length > 0;\n          } else {\n            const type = geometry.getType();\n            drawName = type === 'Point' || type === 'MultiPoint';\n          }\n        }\n      }\n      if (drawName) {\n        name = /** @type {string} */feature.get('name');\n        drawName = drawName && !!name;\n        // convert any html character codes\n        if (drawName && /&[^&]+;/.test(name)) {\n          if (!TEXTAREA) {\n            TEXTAREA = document.createElement('textarea');\n          }\n          TEXTAREA.innerHTML = name;\n          name = TEXTAREA.value;\n        }\n      }\n      let featureStyle = defaultStyle;\n      if (style) {\n        featureStyle = style;\n      } else if (styleUrl) {\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n      }\n      if (drawName) {\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\n        if (multiGeometryPoints.length > 0) {\n          // in multigeometries restrict the name style to points and create a\n          // style without image or text for geometries requiring fill or stroke\n          // including any polygon specific style if there is one\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\n          const baseStyle = new Style({\n            geometry: featureStyle[0].getGeometry(),\n            image: null,\n            fill: featureStyle[0].getFill(),\n            stroke: featureStyle[0].getStroke(),\n            text: null\n          });\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n        }\n        return nameStyle;\n      }\n      return featureStyle;\n    }\n  );\n}\n\n/**\n * @param {Array<Style>|string|undefined} styleValue Style value.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\n * Shared styles.\n * @return {Array<Style>} Style.\n */\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  }\n  if (typeof styleValue === 'string') {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  }\n  return defaultStyle;\n}\n\n/**\n * @param {Node} node Node.\n * @return {import(\"../color.js\").Color|undefined} Color.\n */\nfunction readColor(node) {\n  const s = getAllTextContent(node, false);\n  // The KML specification states that colors should not include a leading `#`\n  // but we tolerate them.\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n  if (m) {\n    const hexColor = m[1];\n    return [parseInt(hexColor.substr(6, 2), 16), parseInt(hexColor.substr(4, 2), 16), parseInt(hexColor.substr(2, 2), 16), parseInt(hexColor.substr(0, 2), 16) / 255];\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {Array<number>|undefined} Flat coordinates.\n */\nexport function readFlatCoordinates(node) {\n  let s = getAllTextContent(node, false);\n  const flatCoordinates = [];\n  // The KML specification states that coordinate tuples should not include\n  // spaces, but we tolerate them.\n  s = s.replace(/\\s*,\\s*/g, ',');\n  const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  let m;\n  while (m = re.exec(s)) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = m[3] ? parseFloat(m[3]) : 0;\n    flatCoordinates.push(x, y, z);\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readURI(node) {\n  const s = getAllTextContent(node, false).trim();\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  }\n  return s;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readStyleURL(node) {\n  // KML files in the wild occasionally forget the leading\n  // `#` on styleUrlsdefined in the same document.\n  const s = getAllTextContent(node, false).trim().replace(/^(?!.*#)/, '#');\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  }\n  return s;\n}\n\n/**\n * @param {Element} node Node.\n * @return {Vec2} Vec2.\n */\nfunction readVec2(node) {\n  const xunits = node.getAttribute('xunits');\n  const yunits = node.getAttribute('yunits');\n  /** @type {import('../style/Icon.js').IconOrigin} */\n  let origin;\n  if (xunits !== 'insetPixels') {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-left';\n    } else {\n      origin = 'top-left';\n    }\n  } else {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-right';\n    } else {\n      origin = 'top-right';\n    }\n  }\n  return {\n    x: parseFloat(node.getAttribute('x')),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node.getAttribute('y')),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin: origin\n  };\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Scale.\n */\nfunction readScale(node) {\n  return readDecimal(node);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Pair': pairDataParser\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>|string|undefined} StyleMap.\n */\nfunction readStyleMapValue(node, objectStack) {\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeObjectPropertySetter(readIcon),\n  'color': makeObjectPropertySetter(readColor),\n  'heading': makeObjectPropertySetter(readDecimal),\n  'hotSpot': makeObjectPropertySetter(readVec2),\n  'scale': makeObjectPropertySetter(readScale)\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction iconStyleParser(node, objectStack) {\n  // FIXME refreshMode\n  // FIXME refreshInterval\n  // FIXME viewRefreshTime\n  // FIXME viewBoundScale\n  // FIXME viewFormat\n  // FIXME httpQuery\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\n  let src;\n  const href = /** @type {string|undefined} */IconObject['href'];\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  let anchor, anchorXUnits, anchorYUnits;\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\n  let anchorOrigin = 'bottom-left';\n  const hotSpot = /** @type {Vec2|undefined} */object['hotSpot'];\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\n    if (src.includes('pushpin')) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('arrow-reverse')) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('paddle')) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n  let offset;\n  const x = /** @type {number|undefined} */IconObject['x'];\n  const y = /** @type {number|undefined} */IconObject['y'];\n  if (x !== undefined && y !== undefined) {\n    offset = [x, y];\n  }\n  let size;\n  const w = /** @type {number|undefined} */IconObject['w'];\n  const h = /** @type {number|undefined} */IconObject['h'];\n  if (w !== undefined && h !== undefined) {\n    size = [w, h];\n  }\n  let rotation;\n  const heading = /** @type {number} */object['heading'];\n  if (heading !== undefined) {\n    rotation = toRadians(heading);\n  }\n  const scale = /** @type {number|undefined} */object['scale'];\n  const color = /** @type {Array<number>|undefined} */object['color'];\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n    const imageStyle = new Icon({\n      anchor: anchor,\n      anchorOrigin: anchorOrigin,\n      anchorXUnits: anchorXUnits,\n      anchorYUnits: anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset,\n      offsetOrigin: 'bottom-left',\n      rotation: rotation,\n      scale: scale,\n      size: size,\n      src: this.iconUrlFunction_(src),\n      color: color\n    });\n    const imageScale = imageStyle.getScaleArray()[0];\n    const imageSize = imageStyle.getSize();\n    if (imageSize === null) {\n      const imageState = imageStyle.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        const listener = function () {\n          const imageState = imageStyle.getImageState();\n          if (!(imageState === ImageState.IDLE || imageState === ImageState.LOADING)) {\n            const imageSize = imageStyle.getSize();\n            if (imageSize && imageSize.length == 2) {\n              const resizeScale = scaleForSize(imageSize);\n              imageStyle.setScale(imageScale * resizeScale);\n            }\n            imageStyle.unlistenImageChange(listener);\n          }\n        };\n        imageStyle.listenImageChange(listener);\n        if (imageState === ImageState.IDLE) {\n          imageStyle.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      const resizeScale = scaleForSize(imageSize);\n      imageStyle.setScale(imageScale * resizeScale);\n    }\n    styleObject['imageStyle'] = imageStyle;\n  } else {\n    // handle the case when we explicitly want to draw no icon.\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'scale': makeObjectPropertySetter(readScale)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction labelStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const textStyle = new Text({\n    fill: new Fill({\n      color: ( /** @type {import(\"../color.js\").Color} */\n      'color' in object ? object['color'] : DEFAULT_COLOR)\n    }),\n    scale: ( /** @type {number|undefined} */object['scale'])\n  });\n  styleObject['textStyle'] = textStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'width': makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lineStyleParser(node, objectStack) {\n  // FIXME colorMode\n  // FIXME gx:outerColor\n  // FIXME gx:outerWidth\n  // FIXME gx:physicalWidth\n  // FIXME gx:labelVisibility\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const strokeStyle = new Stroke({\n    color: ( /** @type {import(\"../color.js\").Color} */\n    'color' in object ? object['color'] : DEFAULT_COLOR),\n    width: ( /** @type {number} */'width' in object ? object['width'] : 1)\n  });\n  styleObject['strokeStyle'] = strokeStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'fill': makeObjectPropertySetter(readBoolean),\n  'outline': makeObjectPropertySetter(readBoolean)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction polyStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const fillStyle = new Fill({\n    color: ( /** @type {import(\"../color.js\").Color} */\n    'color' in object ? object['color'] : DEFAULT_COLOR)\n  });\n  styleObject['fillStyle'] = fillStyle;\n  const fill = /** @type {boolean|undefined} */object['fill'];\n  if (fill !== undefined) {\n    styleObject['fill'] = fill;\n  }\n  const outline = /** @type {boolean|undefined} */object['outline'];\n  if (outline !== undefined) {\n    styleObject['outline'] = outline;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} LinearRing flat coordinates.\n */\nfunction readFlatLinearRing(node, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction gxCoordParser(node, objectStack) {\n  const gxTrackObject = /** @type {GxTrackObject} */\n  objectStack[objectStack.length - 1];\n  const coordinates = gxTrackObject.coordinates;\n  const s = getAllTextContent(node, false);\n  const re = /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  const m = re.exec(s);\n  if (m) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = parseFloat(m[3]);\n    coordinates.push([x, y, z]);\n  } else {\n    coordinates.push([]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  'Track': makeArrayPusher(readGxTrack)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {MultiLineString|undefined} MultiLineString.\n */\nfunction readGxMultiTrack(node, objectStack) {\n  const lineStrings = pushParseAndPop([], GX_MULTITRACK_GEOMETRY_PARSERS, node, objectStack);\n  if (!lineStrings) {\n    return undefined;\n  }\n  return new MultiLineString(lineStrings);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_TRACK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'when': whenParser\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'coord': gxCoordParser\n}));\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readGxTrack(node, objectStack) {\n  const gxTrackObject = pushParseAndPop( /** @type {GxTrackObject} */{\n    coordinates: [],\n    whens: []\n  }, GX_TRACK_PARSERS, node, objectStack);\n  if (!gxTrackObject) {\n    return undefined;\n  }\n  const flatCoordinates = [];\n  const coordinates = gxTrackObject.coordinates;\n  const whens = gxTrackObject.whens;\n  for (let i = 0, ii = Math.min(coordinates.length, whens.length); i < ii; ++i) {\n    if (coordinates[i].length == 3) {\n      flatCoordinates.push(coordinates[i][0], coordinates[i][1], coordinates[i][2], whens[i]);\n    }\n  }\n  return new LineString(flatCoordinates, 'XYZM');\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'x': makeObjectPropertySetter(readDecimal),\n  'y': makeObjectPropertySetter(readDecimal),\n  'w': makeObjectPropertySetter(readDecimal),\n  'h': makeObjectPropertySetter(readDecimal)\n}));\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object} Icon object.\n */\nfunction readIcon(node, objectStack) {\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\n  if (iconObject) {\n    return iconObject;\n  }\n  return null;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} Flat coordinates.\n */\nfunction readFlatCoordinatesFromNode(node, objectStack) {\n  return pushParseAndPop(null, GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeObjectPropertySetter(readBoolean),\n  'tessellate': makeObjectPropertySetter(readBoolean),\n  'altitudeMode': makeObjectPropertySetter(readString)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readLineString(node, objectStack) {\n  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const lineString = new LineString(flatCoordinates, 'XYZ');\n    lineString.setProperties(properties, true);\n    return lineString;\n  }\n  return undefined;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readLinearRing(node, objectStack) {\n  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [flatCoordinates.length]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  }\n  return undefined;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeArrayPusher(readLineString),\n  'LinearRing': makeArrayPusher(readLinearRing),\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\n  'Point': makeArrayPusher(readPoint),\n  'Polygon': makeArrayPusher(readPolygon)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readMultiGeometry(node, objectStack) {\n  const geometries = pushParseAndPop([], MULTI_GEOMETRY_PARSERS, node, objectStack);\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection(geometries);\n  }\n  let multiGeometry;\n  let homogeneous = true;\n  const type = geometries[0].getType();\n  let geometry;\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\n    geometry = geometries[i];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    let layout;\n    let flatCoordinates;\n    if (type == 'Point') {\n      const point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\n        geometry = geometries[i];\n        extend(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'LineString') {\n      multiGeometry = new MultiLineString(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'Polygon') {\n      multiGeometry = new MultiPolygon(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'GeometryCollection') {\n      multiGeometry = new GeometryCollection(geometries);\n    } else {\n      throw new Error('Unknown geometry type found');\n    }\n  } else {\n    multiGeometry = new GeometryCollection(geometries);\n  }\n  return /** @type {import(\"../geom/Geometry.js\").default} */multiGeometry;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Point|undefined} Point.\n */\nfunction readPoint(node, objectStack) {\n  const properties = pushParseAndPop({}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const point = new Point(flatCoordinates, 'XYZ');\n    point.setProperties(properties, true);\n    return point;\n  }\n  return undefined;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'innerBoundaryIs': innerBoundaryIsParser,\n  'outerBoundaryIs': outerBoundaryIsParser\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readPolygon(node, objectStack) {\n  const properties = pushParseAndPop( /** @type {Object<string,*>} */{}, EXTRUDE_AND_ALTITUDE_MODE_PARSERS, node, objectStack);\n  const flatLinearRings = pushParseAndPop([null], FLAT_LINEAR_RINGS_PARSERS, node, objectStack);\n  if (flatLinearRings && flatLinearRings[0]) {\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  }\n  return undefined;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': iconStyleParser,\n  'LabelStyle': labelStyleParser,\n  'LineStyle': lineStyleParser,\n  'PolyStyle': polyStyleParser\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>} Style.\n */\nfunction readStyle(node, objectStack) {\n  const styleObject = pushParseAndPop({}, STYLE_PARSERS, node, objectStack, this);\n  if (!styleObject) {\n    return null;\n  }\n  let fillStyle = /** @type {Fill} */\n\n  'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE;\n  const fill = /** @type {boolean|undefined} */styleObject['fill'];\n  if (fill !== undefined && !fill) {\n    fillStyle = null;\n  }\n  let imageStyle;\n  if ('imageStyle' in styleObject) {\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = /** @type {import(\"../style/Image.js\").default} */\n      styleObject['imageStyle'];\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  const textStyle = /** @type {Text} */\n\n  'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE;\n  const strokeStyle = /** @type {Stroke} */\n\n  'strokeStyle' in styleObject ? styleObject['strokeStyle'] : DEFAULT_STROKE_STYLE;\n  const outline = /** @type {boolean|undefined} */styleObject['outline'];\n  if (outline !== undefined && !outline) {\n    // if the polystyle specifies no outline two styles are needed,\n    // one for non-polygon geometries where linestrings require a stroke\n    // and one for polygons where there should be no stroke\n    return [new Style({\n      geometry: function (feature) {\n        const geometry = feature.getGeometry();\n        const type = geometry.getType();\n        if (type === 'GeometryCollection') {\n          const collection = /** @type {import(\"../geom/GeometryCollection\").default} */\n          geometry;\n          return new GeometryCollection(collection.getGeometriesArrayRecursive().filter(function (geometry) {\n            const type = geometry.getType();\n            return type !== 'Polygon' && type !== 'MultiPolygon';\n          }));\n        }\n        if (type !== 'Polygon' && type !== 'MultiPolygon') {\n          return geometry;\n        }\n      },\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined // FIXME\n    }), new Style({\n      geometry: function (feature) {\n        const geometry = feature.getGeometry();\n        const type = geometry.getType();\n        if (type === 'GeometryCollection') {\n          const collection = /** @type {import(\"../geom/GeometryCollection\").default} */\n          geometry;\n          return new GeometryCollection(collection.getGeometriesArrayRecursive().filter(function (geometry) {\n            const type = geometry.getType();\n            return type === 'Polygon' || type === 'MultiPolygon';\n          }));\n        }\n        if (type === 'Polygon' || type === 'MultiPolygon') {\n          return geometry;\n        }\n      },\n      fill: fillStyle,\n      stroke: null,\n      zIndex: undefined // FIXME\n    })];\n  }\n  return [new Style({\n    fill: fillStyle,\n    image: imageStyle,\n    stroke: strokeStyle,\n    text: textStyle,\n    zIndex: undefined // FIXME\n  })];\n}\n\n/**\n * Reads an array of geometries and creates arrays for common geometry\n * properties. Then sets them to the multi geometry.\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\n */\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  const ii = geometries.length;\n  const extrudes = new Array(geometries.length);\n  const tessellates = new Array(geometries.length);\n  const altitudeModes = new Array(geometries.length);\n  let hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (let i = 0; i < ii; ++i) {\n    const geometry = geometries[i];\n    extrudes[i] = geometry.get('extrude');\n    tessellates[i] = geometry.get('tessellate');\n    altitudeModes[i] = geometry.get('altitudeMode');\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n  }\n  if (hasExtrude) {\n    multiGeometry.set('extrude', extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set('tessellate', tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set('altitudeMode', altitudeModes);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'displayName': makeObjectPropertySetter(readString),\n  'value': makeObjectPropertySetter(readString)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction dataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  parseNode(DATA_PARSERS, node, objectStack);\n  const featureObject = /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function () {\n        return featureObject.value;\n      }\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject['value'];\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': dataParser,\n  'SchemaData': schemaDataParser\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction extendedDataParser(node, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction regionParser(node, objectStack) {\n  parseNode(REGION_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Style': makeObjectPropertySetter(readStyle),\n  'key': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction pairDataParser(node, objectStack) {\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  const key = /** @type {string|undefined} */pairObject['key'];\n  if (key && key == 'normal') {\n    const styleUrl = /** @type {string|undefined} */pairObject['styleUrl'];\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    const style = /** @type {Style} */pairObject['Style'];\n    if (style) {\n      objectStack[objectStack.length - 1] = style;\n    }\n  }\n}\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction placemarkStyleMapParser(node, objectStack) {\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  const placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject['Style'] = styleMapValue;\n  } else if (typeof styleMapValue === 'string') {\n    placemarkObject['styleUrl'] = styleMapValue;\n  } else {\n    throw new Error('`styleMapValue` has an unknown type');\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'SimpleData': simpleDataParser\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction schemaDataParser(node, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction simpleDataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (name !== null) {\n    const data = readString(node);\n    const featureObject = /** @type {Object} */\n    objectStack[objectStack.length - 1];\n    featureObject[name] = data;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'altitudeMode': makeObjectPropertySetter(readString),\n  'minAltitude': makeObjectPropertySetter(readDecimal),\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\n  'north': makeObjectPropertySetter(readDecimal),\n  'south': makeObjectPropertySetter(readDecimal),\n  'east': makeObjectPropertySetter(readDecimal),\n  'west': makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction latLonAltBoxParser(node, objectStack) {\n  const object = pushParseAndPop({}, LAT_LON_ALT_BOX_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const regionObject = /** @type {Object} */\n  objectStack[objectStack.length - 1];\n  const extent = [parseFloat(object['west']), parseFloat(object['south']), parseFloat(object['east']), parseFloat(object['north'])];\n  regionObject['extent'] = extent;\n  regionObject['altitudeMode'] = object['altitudeMode'];\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lodParser(node, objectStack) {\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const lodObject = /** @type {Object} */objectStack[objectStack.length - 1];\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\n  // allows multiple, so we parse multiple here too.\n  'LinearRing': makeArrayPusher(readFlatLinearRing)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction innerBoundaryIsParser(node, objectStack) {\n  const innerBoundaryFlatLinearRings = pushParseAndPop( /** @type {Array<Array<number>>} */[], INNER_BOUNDARY_IS_PARSERS, node, objectStack);\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    const flatLinearRings = /** @type {Array<Array<number>>} */\n    objectStack[objectStack.length - 1];\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeReplacer(readFlatLinearRing)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction outerBoundaryIsParser(node, objectStack) {\n  /** @type {Array<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(undefined, OUTER_BOUNDARY_IS_PARSERS, node, objectStack);\n  if (flatLinearRing) {\n    const flatLinearRings = /** @type {Array<Array<number>>} */\n    objectStack[objectStack.length - 1];\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction linkParser(node, objectStack) {\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction whenParser(node, objectStack) {\n  const gxTrackObject = /** @type {GxTrackObject} */\n  objectStack[objectStack.length - 1];\n  const whens = gxTrackObject.whens;\n  const s = getAllTextContent(node, false);\n  const when = Date.parse(s);\n  whens.push(isNaN(when) ? 0 : when);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the color to.\n * @param {import(\"../color.js\").Color|string} color Color.\n */\nfunction writeColorTextNode(node, color) {\n  const rgba = asArray(color);\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\n  /** @type {Array<string|number>} */\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n  for (let i = 0; i < 4; ++i) {\n    const hex = Math.floor( /** @type {number} */abgr[i]).toString(16);\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\n  }\n  writeStringTextNode(node, abgr.join(''));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the coordinates to.\n * @param {Array<number>} coordinates Coordinates.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const layout = context['layout'];\n  const stride = context['stride'];\n  let dimension;\n  if (layout == 'XY' || layout == 'XYM') {\n    dimension = 2;\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\n    dimension = 3;\n  } else {\n    throw new Error('Invalid geometry layout');\n  }\n  const ii = coordinates.length;\n  let text = '';\n  if (ii > 0) {\n    text += coordinates[0];\n    for (let d = 1; d < dimension; ++d) {\n      text += ',' + coordinates[d];\n    }\n    for (let i = stride; i < ii; i += stride) {\n      text += ' ' + coordinates[i];\n      for (let d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[i + d];\n      }\n    }\n  }\n  writeStringTextNode(node, text);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': makeChildAppender(writeDataNode),\n  'value': makeChildAppender(writeDataNodeValue),\n  'displayName': makeChildAppender(writeDataNodeName)\n});\n\n/**\n * @param {Element} node Node.\n * @param {{name: *, value: *}} pair Name value pair.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeDataNode(node, pair, objectStack) {\n  node.setAttribute('name', pair.name);\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const value = pair.value;\n  if (typeof value == 'object') {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.displayName], objectStack, ['displayName']);\n    }\n    if (value !== null && value.value) {\n      pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value.value], objectStack, ['value']);\n    }\n  } else {\n    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, [value], objectStack, ['value']);\n  }\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the name to.\n * @param {string} name DisplayName.\n */\nfunction writeDataNodeName(node, name) {\n  writeCDATASection(node, name);\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the value to.\n * @param {string} value Value.\n */\nfunction writeDataNodeValue(node, value) {\n  writeStringTextNode(node, value);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Placemark': makeChildAppender(writePlacemark)\n});\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<Feature>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writeDocument(node, features, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  pushSerializeAndPop(context, DOCUMENT_SERIALIZERS, DOCUMENT_NODE_FACTORY, features, objectStack, undefined, this);\n}\n\n/**\n * A factory for creating Data nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\n\n/**\n * @param {Element} node Node.\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeExtendedData(node, namesAndValues, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const names = namesAndValues.names;\n  const values = namesAndValues.values;\n  const length = names.length;\n  for (let i = 0; i < length; i++) {\n    pushSerializeAndPop(context, EXTENDEDDATA_NODE_SERIALIZERS, DATA_NODE_FACTORY, [{\n      name: names[i],\n      value: values[i]\n    }], objectStack);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['href'], makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h']));\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeChildAppender(writeStringTextNode)\n}, makeStructureNS(GX_NAMESPACE_URIS, {\n  'x': makeChildAppender(writeDecimalTextNode),\n  'y': makeChildAppender(writeDecimalTextNode),\n  'w': makeChildAppender(writeDecimalTextNode),\n  'h': makeChildAppender(writeDecimalTextNode)\n}));\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\n};\n\n/**\n * @param {Element} node Node.\n * @param {Object} icon Icon object.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIcon(node, icon, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  let values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(context, ICON_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(context, ICON_SERIALIZERS, GX_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['scale', 'heading', 'Icon', 'color', 'hotSpot']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeChildAppender(writeIcon),\n  'color': makeChildAppender(writeColorTextNode),\n  'heading': makeChildAppender(writeDecimalTextNode),\n  'hotSpot': makeChildAppender(writeVec2),\n  'scale': makeChildAppender(writeScaleTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../style/Icon.js\").default} style Icon style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIconStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const /** @type {Object<string, any>} */properties = {};\n  const src = style.getSrc();\n  const size = style.getSize();\n  const iconImageSize = style.getImageSize();\n  const iconProperties = {\n    'href': src\n  };\n  if (size) {\n    iconProperties['w'] = size[0];\n    iconProperties['h'] = size[1];\n    const anchor = style.getAnchor(); // top-left\n    const origin = style.getOrigin(); // top-left\n\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n      iconProperties['x'] = origin[0];\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n    }\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      const /** @type {Vec2} */hotSpot = {\n        x: anchor[0],\n        xunits: 'pixels',\n        y: size[1] - anchor[1],\n        yunits: 'pixels'\n      };\n      properties['hotSpot'] = hotSpot;\n    }\n  }\n  properties['Icon'] = iconProperties;\n  let scale = style.getScaleArray()[0];\n  let imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    const resizeScale = scaleForSize(imageSize);\n    scale = scale / resizeScale;\n  }\n  if (scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const rotation = style.getRotation();\n  if (rotation !== 0) {\n    properties['heading'] = rotation; // 0-360\n  }\n  const color = style.getColor();\n  if (color) {\n    properties['color'] = color;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, ICON_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'scale']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'scale': makeChildAppender(writeScaleTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Text} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLabelStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const properties = {};\n  const fill = style.getFill();\n  if (fill) {\n    properties['color'] = fill.getColor();\n  }\n  const scale = style.getScale();\n  if (scale && scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, LABEL_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'width': makeChildAppender(writeDecimalTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Stroke} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLineStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const properties = {\n    'color': style.getColor(),\n    'width': Number(style.getWidth()) || 1\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, LINE_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'Point',\n  'LineString': 'LineString',\n  'LinearRing': 'LinearRing',\n  'Polygon': 'Polygon',\n  'MultiPoint': 'MultiGeometry',\n  'MultiLineString': 'MultiGeometry',\n  'MultiPolygon': 'MultiGeometry',\n  'GeometryCollection': 'MultiGeometry'\n};\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\n  if (value) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(parentNode.namespaceURI, GEOMETRY_TYPE_TO_NODENAME[/** @type {import(\"../geom/Geometry.js\").default} */value.getType()]);\n  }\n};\n\n/**\n * A factory for creating Point nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\n\n/**\n * A factory for creating LineString nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\n\n/**\n * A factory for creating LinearRing nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\n\n/**\n * A factory for creating Polygon nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'GeometryCollection': makeChildAppender(writeMultiGeometry)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeMultiGeometry(node, geometry, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {\n    node: node\n  };\n  const type = geometry.getType();\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\n  let geometries = [];\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\n  let factory;\n  if (type === 'GeometryCollection') {\n    /** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().forEach(function (geometry) {\n      const type = geometry.getType();\n      if (type === 'MultiPoint') {\n        geometries = geometries.concat( /** @type {MultiPoint} */geometry.getPoints());\n      } else if (type === 'MultiLineString') {\n        geometries = geometries.concat( /** @type {MultiLineString} */geometry.getLineStrings());\n      } else if (type === 'MultiPolygon') {\n        geometries = geometries.concat( /** @type {MultiPolygon} */geometry.getPolygons());\n      } else if (type === 'Point' || type === 'LineString' || type === 'Polygon') {\n        geometries.push(geometry);\n      } else {\n        throw new Error('Unknown geometry type');\n      }\n    });\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === 'MultiPoint') {\n    geometries = /** @type {MultiPoint} */geometry.getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === 'MultiLineString') {\n    geometries = /** @type {MultiLineString} */geometry.getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === 'MultiPolygon') {\n    geometries = /** @type {MultiPolygon} */geometry.getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    throw new Error('Unknown geometry type');\n  }\n  pushSerializeAndPop(context, MULTI_GEOMETRY_SERIALIZERS, factory, geometries, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeChildAppender(writePrimitiveGeometry)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeBoundaryIs(node, linearRing, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  pushSerializeAndPop(context, BOUNDARY_IS_SERIALIZERS, LINEAR_RING_NODE_FACTORY, [linearRing], objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': makeChildAppender(writeExtendedData),\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'Style': makeChildAppender(writeStyle),\n  'address': makeChildAppender(writeStringTextNode),\n  'description': makeChildAppender(writeStringTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'open': makeChildAppender(writeBooleanTextNode),\n  'phoneNumber': makeChildAppender(writeStringTextNode),\n  'styleUrl': makeChildAppender(writeStringTextNode),\n  'visibility': makeChildAppender(writeBooleanTextNode)\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['name', 'open', 'visibility', 'address', 'phoneNumber', 'description', 'styleUrl', 'Style']);\n\n/**\n * A factory for creating ExtendedData nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\n\n/**\n * FIXME currently we do serialize arbitrary/custom feature properties\n * (ExtendedData).\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writePlacemark(node, feature, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n\n  // set id\n  if (feature.getId()) {\n    node.setAttribute('id', /** @type {string} */feature.getId());\n  }\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = feature.getProperties();\n\n  // don't export these to ExtendedData\n  const filter = {\n    'address': 1,\n    'description': 1,\n    'name': 1,\n    'open': 1,\n    'phoneNumber': 1,\n    'styleUrl': 1,\n    'visibility': 1\n  };\n  filter[feature.getGeometryName()] = 1;\n  const keys = Object.keys(properties || {}).sort().filter(function (v) {\n    return !filter[v];\n  });\n  const styleFunction = feature.getStyleFunction();\n  if (styleFunction) {\n    // FIXME the styles returned by the style function are supposed to be\n    // resolution-independent here\n    const styles = styleFunction(feature, 0);\n    if (styles) {\n      const styleArray = Array.isArray(styles) ? styles : [styles];\n      let pointStyles = styleArray;\n      if (feature.getGeometry()) {\n        pointStyles = styleArray.filter(function (style) {\n          const geometry = style.getGeometryFunction()(feature);\n          if (geometry) {\n            const type = geometry.getType();\n            if (type === 'GeometryCollection') {\n              return /** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n                const type = geometry.getType();\n                return type === 'Point' || type === 'MultiPoint';\n              }).length;\n            }\n            return type === 'Point' || type === 'MultiPoint';\n          }\n        });\n        'Point';\n      }\n      if (this.writeStyles_) {\n        let lineStyles = styleArray;\n        let polyStyles = styleArray;\n        if (feature.getGeometry()) {\n          lineStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'LineString' || type === 'MultiLineString';\n                }).length;\n              }\n              return type === 'LineString' || type === 'MultiLineString';\n            }\n          });\n          polyStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */geometry.getGeometriesArrayRecursive().filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Polygon' || type === 'MultiPolygon';\n                }).length;\n              }\n              return type === 'Polygon' || type === 'MultiPolygon';\n            }\n          });\n        }\n        properties['Style'] = {\n          pointStyles: pointStyles,\n          lineStyles: lineStyles,\n          polyStyles: polyStyles\n        };\n      }\n      if (pointStyles.length && properties['name'] === undefined) {\n        const textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n  if (keys.length > 0) {\n    const sequence = makeSequence(properties, keys);\n    const namesAndValues = {\n      names: keys,\n      values: sequence\n    };\n    pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, EXTENDEDDATA_NODE_FACTORY, [namesAndValues], objectStack);\n  }\n\n  // serialize geometry\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */\n  objectStack[0];\n  let geometry = feature.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(context, PLACEMARK_SERIALIZERS, GEOMETRY_NODE_FACTORY, [geometry], objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['extrude', 'tessellate', 'altitudeMode', 'coordinates']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeChildAppender(writeBooleanTextNode),\n  'tessellate': makeChildAppender(writeBooleanTextNode),\n  'altitudeMode': makeChildAppender(writeStringTextNode),\n  'coordinates': makeChildAppender(writeCoordinatesTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  context['layout'] = geometry.getLayout();\n  context['stride'] = geometry.getStride();\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, PRIMITIVE_GEOMETRY_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'fill', 'outline']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs)\n});\n\n/**\n * A factory for creating innerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\n\n/**\n * A factory for creating outerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\n\n/**\n * @param {Element} node Node.\n * @param {Polygon} polygon Polygon.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolygon(node, polygon, objectStack) {\n  const linearRings = polygon.getLinearRings();\n  const outerRing = linearRings.shift();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  // inner rings\n  pushSerializeAndPop(context, POLYGON_SERIALIZERS, INNER_BOUNDARY_NODE_FACTORY, linearRings, objectStack);\n  // outer ring\n  pushSerializeAndPop(context, POLYGON_SERIALIZERS, OUTER_BOUNDARY_NODE_FACTORY, [outerRing], objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'fill': makeChildAppender(writeBooleanTextNode),\n  'outline': makeChildAppender(writeBooleanTextNode)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Style} style Style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolyStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const fill = style.getFill();\n  const stroke = style.getStroke();\n  const properties = {\n    'color': fill ? fill.getColor() : undefined,\n    'fill': fill ? undefined : false,\n    'outline': stroke ? undefined : false\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, POLY_STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the scale to.\n * @param {number|undefined} scale Scale.\n */\nfunction writeScaleTextNode(node, scale) {\n  // the Math is to remove any excess decimals created by float arithmetic\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['IconStyle', 'LabelStyle', 'LineStyle', 'PolyStyle']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': makeChildAppender(writeIconStyle),\n  'LabelStyle': makeChildAppender(writeLabelStyle),\n  'LineStyle': makeChildAppender(writeLineStyle),\n  'PolyStyle': makeChildAppender(writePolyStyle)\n});\n\n/**\n * @param {Element} node Node.\n * @param {Object<string, Array<Style>>} styles Styles.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeStyle(node, styles, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */context = {\n    node: node\n  };\n  const properties = {};\n  if (styles.pointStyles.length) {\n    const textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    const imageStyle = styles.pointStyles[0].getImage();\n    if (imageStyle && typeof ( /** @type {?} */imageStyle.getSrc) === 'function') {\n      properties['IconStyle'] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    const strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    const strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties['LineStyle']) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    properties['PolyStyle'] = styles.polyStyles[0];\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(context, STYLE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, orderedKeys);\n}\n\n/**\n * @param {Element} node Node to append a TextNode with the Vec2 to.\n * @param {Vec2} vec2 Vec2.\n */\nfunction writeVec2(node, vec2) {\n  node.setAttribute('x', String(vec2.x));\n  node.setAttribute('y', String(vec2.y));\n  node.setAttribute('xunits', vec2.xunits);\n  node.setAttribute('yunits', vec2.yunits);\n}\nexport default KML;","map":{"version":3,"names":["Feature","Fill","GeometryCollection","Icon","ImageState","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","Stroke","Style","Text","XMLFeature","OBJECT_PROPERTY_NODE_FACTORY","XML_SCHEMA_INSTANCE_URI","createElementNS","getAllTextContent","isDocument","makeArrayExtender","makeArrayPusher","makeChildAppender","makeObjectPropertySetter","makeReplacer","makeSequence","makeSimpleNodeFactory","makeStructureNS","parse","parseNode","pushParseAndPop","pushSerializeAndPop","asArray","extend","get","getProjection","readBoolean","readDecimal","readString","writeBooleanTextNode","writeCDATASection","writeDecimalTextNode","writeStringTextNode","toRadians","transformGeometryWithOptions","GX_NAMESPACE_URIS","NAMESPACE_URIS","SCHEMA_LOCATION","ICON_ANCHOR_UNITS_MAP","PLACEMARK_PARSERS","extendedDataParser","regionParser","readMultiGeometry","readLineString","readLinearRing","readPoint","readPolygon","readStyle","placemarkStyleMapParser","readStyleURL","readGxMultiTrack","readGxTrack","NETWORK_LINK_PARSERS","linkParser","LINK_PARSERS","readURI","CAMERA_PARSERS","Altitude","Longitude","Latitude","Tilt","AltitudeMode","Heading","Roll","REGION_PARSERS","latLonAltBoxParser","lodParser","KML_SEQUENCE","KML_SERIALIZERS","writeDocument","writePlacemark","DEFAULT_COLOR","DEFAULT_FILL_STYLE","getDefaultFillStyle","DEFAULT_IMAGE_STYLE_ANCHOR","DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS","DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS","DEFAULT_IMAGE_STYLE_SIZE","DEFAULT_IMAGE_STYLE_SRC","DEFAULT_IMAGE_STYLE","getDefaultImageStyle","DEFAULT_NO_IMAGE_STYLE","DEFAULT_STROKE_STYLE","getDefaultStrokeStyle","DEFAULT_TEXT_STROKE_STYLE","DEFAULT_TEXT_STYLE","getDefaultTextStyle","DEFAULT_STYLE","getDefaultStyle","DEFAULT_STYLE_ARRAY","getDefaultStyleArray","scaleForSize","size","Math","min","createStyleDefaults","color","anchor","anchorOrigin","anchorXUnits","anchorYUnits","crossOrigin","rotation","scale","src","width","font","fill","stroke","image","text","zIndex","TEXTAREA","defaultIconUrlFunction","href","KML","constructor","options","dataProjection","defaultStyle_","defaultStyle","extractStyles_","extractStyles","undefined","writeStyles_","writeStyles","sharedStyles_","showPointNames_","showPointNames","crossOrigin_","iconUrlFunction_","iconUrlFunction","supportedMediaTypes","readDocumentOrFolder_","node","objectStack","parsersNS","readPlacemark_","readSharedStyle_","bind","readSharedStyleMap_","features","object","feature","id","getAttribute","setId","geometry","setGeometry","style","styleUrl","styleFunction","createFeatureStyleFunction","setStyle","setProperties","call","styleUri","baseURI","window","location","url","URL","styleMapValue","readStyleMapValue","readFeatureFromNode","includes","namespaceURI","getReadOptions","readFeaturesFromNode","localName","n","firstElementChild","nextElementSibling","fs","readName","source","doc","readNameFromDocument","readNameFromNode","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","name","readNetworkLinks","networkLinks","readNetworkLinksFromDocument","readNetworkLinksFromNode","obj","push","readRegion","regions","readRegionFromDocument","readRegionFromNode","readCamera","cameras","readCameraFromDocument","readCameraFromNode","writeFeaturesNode","adaptOptions","kml","xmlnsUri","setAttributeNS","context","properties","length","orderedKeys","values","createNameStyleFunction","foundStyle","textOffset","textAlign","imageStyle","getImage","imageSize","getSize","imageScale","getScaleArray","getAnchor","textStyle","getText","clone","setFont","getFont","setScale","getScale","setFill","getFill","setStroke","getStroke","setText","setOffsetX","setOffsetY","setTextAlign","nameStyle","sharedStyles","resolution","drawName","multiGeometryPoints","getGeometry","getGeometriesArrayRecursive","filter","type","getType","test","document","createElement","innerHTML","value","featureStyle","findStyle","baseStyle","concat","slice","styleValue","Array","isArray","readColor","s","m","exec","hexColor","parseInt","substr","readFlatCoordinates","flatCoordinates","replace","re","x","parseFloat","y","z","trim","readVec2","xunits","yunits","origin","readScale","STYLE_MAP_PARSERS","pairDataParser","ICON_STYLE_PARSERS","readIcon","iconStyleParser","styleObject","IconObject","drawIcon","Object","keys","hotSpot","offset","w","h","heading","offsetOrigin","imageState","getImageState","IDLE","LOADING","listener","resizeScale","unlistenImageChange","listenImageChange","load","LABEL_STYLE_PARSERS","labelStyleParser","LINE_STYLE_PARSERS","lineStyleParser","strokeStyle","POLY_STYLE_PARSERS","polyStyleParser","fillStyle","outline","FLAT_LINEAR_RING_PARSERS","readFlatLinearRing","gxCoordParser","gxTrackObject","coordinates","GX_MULTITRACK_GEOMETRY_PARSERS","lineStrings","GX_TRACK_PARSERS","whenParser","whens","i","ii","ICON_PARSERS","iconObject","GEOMETRY_FLAT_COORDINATES_PARSERS","readFlatCoordinatesFromNode","EXTRUDE_AND_ALTITUDE_MODE_PARSERS","lineString","polygon","MULTI_GEOMETRY_PARSERS","geometries","multiGeometry","homogeneous","layout","point","getLayout","getFlatCoordinates","setCommonGeometryProperties","Error","FLAT_LINEAR_RINGS_PARSERS","innerBoundaryIsParser","outerBoundaryIsParser","flatLinearRings","ends","STYLE_PARSERS","collection","extrudes","tessellates","altitudeModes","hasExtrude","hasTessellate","hasAltitudeMode","set","DATA_PARSERS","dataParser","featureObject","displayName","toString","EXTENDED_DATA_PARSERS","schemaDataParser","PAIR_PARSERS","pairObject","key","placemarkObject","SCHEMA_DATA_PARSERS","simpleDataParser","data","LAT_LON_ALT_BOX_PARSERS","regionObject","extent","LOD_PARSERS","lodObject","INNER_BOUNDARY_IS_PARSERS","innerBoundaryFlatLinearRings","OUTER_BOUNDARY_IS_PARSERS","flatLinearRing","when","Date","isNaN","writeColorTextNode","rgba","opacity","abgr","hex","floor","join","writeCoordinatesTextNode","stride","dimension","d","EXTENDEDDATA_NODE_SERIALIZERS","writeDataNode","writeDataNodeValue","writeDataNodeName","pair","setAttribute","DOCUMENT_SERIALIZERS","DOCUMENT_NODE_FACTORY","nodeName","parentNode","DATA_NODE_FACTORY","writeExtendedData","namesAndValues","names","ICON_SEQUENCE","ICON_SERIALIZERS","GX_NODE_FACTORY","writeIcon","icon","ICON_STYLE_SEQUENCE","ICON_STYLE_SERIALIZERS","writeVec2","writeScaleTextNode","writeIconStyle","getSrc","iconImageSize","getImageSize","iconProperties","getOrigin","getRotation","getColor","LABEL_STYLE_SEQUENCE","LABEL_STYLE_SERIALIZERS","writeLabelStyle","LINE_STYLE_SEQUENCE","LINE_STYLE_SERIALIZERS","writeLineStyle","Number","getWidth","GEOMETRY_TYPE_TO_NODENAME","GEOMETRY_NODE_FACTORY","POINT_NODE_FACTORY","LINE_STRING_NODE_FACTORY","LINEAR_RING_NODE_FACTORY","POLYGON_NODE_FACTORY","MULTI_GEOMETRY_SERIALIZERS","writePrimitiveGeometry","writePolygon","writeMultiGeometry","factory","forEach","getPoints","getLineStrings","getPolygons","BOUNDARY_IS_SERIALIZERS","writeBoundaryIs","linearRing","PLACEMARK_SERIALIZERS","writeStyle","PLACEMARK_SEQUENCE","EXTENDEDDATA_NODE_FACTORY","getId","getProperties","getGeometryName","sort","v","getStyleFunction","styles","styleArray","pointStyles","getGeometryFunction","lineStyles","polyStyles","sequence","PRIMITIVE_GEOMETRY_SEQUENCE","PRIMITIVE_GEOMETRY_SERIALIZERS","getStride","POLY_STYLE_SEQUENCE","POLYGON_SERIALIZERS","INNER_BOUNDARY_NODE_FACTORY","OUTER_BOUNDARY_NODE_FACTORY","linearRings","getLinearRings","outerRing","shift","POLY_STYLE_SERIALIZERS","writePolyStyle","round","STYLE_SEQUENCE","STYLE_SERIALIZERS","vec2","String"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/KML.js"],"sourcesContent":["/**\n * @module ol/format/KML\n */\nimport Feature from '../Feature.js';\nimport Fill from '../style/Fill.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport Icon from '../style/Icon.js';\nimport ImageState from '../ImageState.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport Stroke from '../style/Stroke.js';\nimport Style from '../style/Style.js';\nimport Text from '../style/Text.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  isDocument,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeReplacer,\n  makeSequence,\n  makeSimpleNodeFactory,\n  makeStructureNS,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {asArray} from '../color.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readBoolean,\n  readDecimal,\n  readString,\n  writeBooleanTextNode,\n  writeCDATASection,\n  writeDecimalTextNode,\n  writeStringTextNode,\n} from './xsd.js';\nimport {toRadians} from '../math.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {Object} Vec2\n * @property {number} x X coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} xunits Units of x.\n * @property {number} y Y coordinate.\n * @property {import(\"../style/Icon.js\").IconAnchorUnits} yunits Units of Y.\n * @property {import(\"../style/Icon.js\").IconOrigin} [origin] Origin.\n */\n\n/**\n * @typedef {Object} GxTrackObject\n * @property {Array<Array<number>>} coordinates Coordinates.\n * @property {Array<number>} whens Whens.\n */\n\n/**\n * @const\n * @type {Array<string>}\n */\nconst GX_NAMESPACE_URIS = ['http://www.google.com/kml/ext/2.2'];\n\n/**\n * @const\n * @type {Array<null|string>}\n */\nconst NAMESPACE_URIS = [\n  null,\n  'http://earth.google.com/kml/2.0',\n  'http://earth.google.com/kml/2.1',\n  'http://earth.google.com/kml/2.2',\n  'http://www.opengis.net/kml/2.2',\n];\n\n/**\n * @const\n * @type {string}\n */\nconst SCHEMA_LOCATION =\n  'http://www.opengis.net/kml/2.2 ' +\n  'https://developers.google.com/kml/schema/kml22gx.xsd';\n\n/**\n * @type {Object<string, import(\"../style/Icon.js\").IconAnchorUnits>}\n */\nconst ICON_ANCHOR_UNITS_MAP = {\n  'fraction': 'fraction',\n  'pixels': 'pixels',\n  'insetPixels': 'pixels',\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PLACEMARK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'ExtendedData': extendedDataParser,\n    'Region': regionParser,\n    'MultiGeometry': makeObjectPropertySetter(readMultiGeometry, 'geometry'),\n    'LineString': makeObjectPropertySetter(readLineString, 'geometry'),\n    'LinearRing': makeObjectPropertySetter(readLinearRing, 'geometry'),\n    'Point': makeObjectPropertySetter(readPoint, 'geometry'),\n    'Polygon': makeObjectPropertySetter(readPolygon, 'geometry'),\n    'Style': makeObjectPropertySetter(readStyle),\n    'StyleMap': placemarkStyleMapParser,\n    'address': makeObjectPropertySetter(readString),\n    'description': makeObjectPropertySetter(readString),\n    'name': makeObjectPropertySetter(readString),\n    'open': makeObjectPropertySetter(readBoolean),\n    'phoneNumber': makeObjectPropertySetter(readString),\n    'styleUrl': makeObjectPropertySetter(readStyleURL),\n    'visibility': makeObjectPropertySetter(readBoolean),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'MultiTrack': makeObjectPropertySetter(readGxMultiTrack, 'geometry'),\n    'Track': makeObjectPropertySetter(readGxTrack, 'geometry'),\n  }),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst NETWORK_LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': extendedDataParser,\n  'Region': regionParser,\n  'Link': linkParser,\n  'address': makeObjectPropertySetter(readString),\n  'description': makeObjectPropertySetter(readString),\n  'name': makeObjectPropertySetter(readString),\n  'open': makeObjectPropertySetter(readBoolean),\n  'phoneNumber': makeObjectPropertySetter(readString),\n  'visibility': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINK_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'href': makeObjectPropertySetter(readURI),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst CAMERA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  Altitude: makeObjectPropertySetter(readDecimal),\n  Longitude: makeObjectPropertySetter(readDecimal),\n  Latitude: makeObjectPropertySetter(readDecimal),\n  Tilt: makeObjectPropertySetter(readDecimal),\n  AltitudeMode: makeObjectPropertySetter(readString),\n  Heading: makeObjectPropertySetter(readDecimal),\n  Roll: makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst REGION_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LatLonAltBox': latLonAltBoxParser,\n  'Lod': lodParser,\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst KML_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['Document', 'Placemark']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst KML_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Document': makeChildAppender(writeDocument),\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @type {import(\"../color.js\").Color}\n */\nlet DEFAULT_COLOR;\n\n/**\n * @type {Fill|null}\n */\nlet DEFAULT_FILL_STYLE = null;\n\n/**\n * Get the default fill style (or null if not yet set).\n * @return {Fill|null} The default fill style.\n */\nexport function getDefaultFillStyle() {\n  return DEFAULT_FILL_STYLE;\n}\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n\n/**\n * @type {import(\"../style/Icon.js\").IconAnchorUnits}\n */\nlet DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n\n/**\n * @type {import(\"../size.js\").Size}\n */\nlet DEFAULT_IMAGE_STYLE_SIZE;\n\n/**\n * @type {string}\n */\nlet DEFAULT_IMAGE_STYLE_SRC;\n\n/**\n * @type {import(\"../style/Image.js\").default|null}\n */\nlet DEFAULT_IMAGE_STYLE = null;\n\n/**\n * Get the default image style (or null if not yet set).\n * @return {import(\"../style/Image.js\").default|null} The default image style.\n */\nexport function getDefaultImageStyle() {\n  return DEFAULT_IMAGE_STYLE;\n}\n\n/**\n * @type {string}\n */\nlet DEFAULT_NO_IMAGE_STYLE;\n\n/**\n * @type {Stroke|null}\n */\nlet DEFAULT_STROKE_STYLE = null;\n\n/**\n * Get the default stroke style (or null if not yet set).\n * @return {Stroke|null} The default stroke style.\n */\nexport function getDefaultStrokeStyle() {\n  return DEFAULT_STROKE_STYLE;\n}\n\n/**\n * @type {Stroke}\n */\nlet DEFAULT_TEXT_STROKE_STYLE;\n\n/**\n * @type {Text|null}\n */\nlet DEFAULT_TEXT_STYLE = null;\n\n/**\n * Get the default text style (or null if not yet set).\n * @return {Text|null} The default text style.\n */\nexport function getDefaultTextStyle() {\n  return DEFAULT_TEXT_STYLE;\n}\n\n/**\n * @type {Style|null}\n */\nlet DEFAULT_STYLE = null;\n\n/**\n * Get the default style (or null if not yet set).\n * @return {Style|null} The default style.\n */\nexport function getDefaultStyle() {\n  return DEFAULT_STYLE;\n}\n\n/**\n * @type {Array<Style>|null}\n */\nlet DEFAULT_STYLE_ARRAY = null;\n\n/**\n * Get the default style array (or null if not yet set).\n * @return {Array<Style>|null} The default style.\n */\nexport function getDefaultStyleArray() {\n  return DEFAULT_STYLE_ARRAY;\n}\n\n/**\n * Function that returns the scale needed to normalize an icon image to 32 pixels.\n * @param {import(\"../size.js\").Size} size Image size.\n * @return {number} Scale.\n */\nfunction scaleForSize(size) {\n  return 32 / Math.min(size[0], size[1]);\n}\n\nfunction createStyleDefaults() {\n  DEFAULT_COLOR = [255, 255, 255, 1];\n\n  DEFAULT_FILL_STYLE = new Fill({\n    color: DEFAULT_COLOR,\n  });\n\n  DEFAULT_IMAGE_STYLE_ANCHOR = [20, 2];\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS = 'pixels';\n\n  DEFAULT_IMAGE_STYLE_SIZE = [64, 64];\n\n  DEFAULT_IMAGE_STYLE_SRC =\n    'https://maps.google.com/mapfiles/kml/pushpin/ylw-pushpin.png';\n\n  DEFAULT_IMAGE_STYLE = new Icon({\n    anchor: DEFAULT_IMAGE_STYLE_ANCHOR,\n    anchorOrigin: 'bottom-left',\n    anchorXUnits: DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS,\n    anchorYUnits: DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS,\n    crossOrigin: 'anonymous',\n    rotation: 0,\n    scale: scaleForSize(DEFAULT_IMAGE_STYLE_SIZE),\n    size: DEFAULT_IMAGE_STYLE_SIZE,\n    src: DEFAULT_IMAGE_STYLE_SRC,\n  });\n\n  DEFAULT_NO_IMAGE_STYLE = 'NO_IMAGE';\n\n  DEFAULT_STROKE_STYLE = new Stroke({\n    color: DEFAULT_COLOR,\n    width: 1,\n  });\n\n  DEFAULT_TEXT_STROKE_STYLE = new Stroke({\n    color: [51, 51, 51, 1],\n    width: 2,\n  });\n\n  DEFAULT_TEXT_STYLE = new Text({\n    font: 'bold 16px Helvetica',\n    fill: DEFAULT_FILL_STYLE,\n    stroke: DEFAULT_TEXT_STROKE_STYLE,\n    scale: 0.8,\n  });\n\n  DEFAULT_STYLE = new Style({\n    fill: DEFAULT_FILL_STYLE,\n    image: DEFAULT_IMAGE_STYLE,\n    text: DEFAULT_TEXT_STYLE,\n    stroke: DEFAULT_STROKE_STYLE,\n    zIndex: 0,\n  });\n\n  DEFAULT_STYLE_ARRAY = [DEFAULT_STYLE];\n}\n\n/**\n * @type {HTMLTextAreaElement}\n */\nlet TEXTAREA;\n\n/**\n * A function that takes a url `{string}` and returns a url `{string}`.\n * Might be used to change an icon path or to substitute a\n * data url obtained from a KMZ array buffer.\n *\n * @typedef {function(string):string} IconUrlFunction\n * @api\n */\n\n/**\n * Function that returns a url unchanged.\n * @param {string} href Input url.\n * @return {string} Output url.\n */\nfunction defaultIconUrlFunction(href) {\n  return href;\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [extractStyles=true] Extract styles from the KML.\n * @property {boolean} [showPointNames=true] Show names as labels for placemarks which contain points.\n * @property {Array<Style>} [defaultStyle] Default style. The\n * default default style is the same as Google Earth.\n * @property {boolean} [writeStyles=true] Write styles into KML.\n * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images. Note that you must provide a\n * `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * @property {IconUrlFunction} [iconUrlFunction] Function that takes a url string and returns a url string.\n * Might be used to change an icon path or to substitute a data url obtained from a KMZ array buffer.\n */\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the KML format.\n *\n * {@link module:ol/format/KML~KML#readFeature} will read the first feature from\n * a KML source.\n *\n * MultiGeometries are converted into GeometryCollections if they are a mix of\n * geometry types, and into MultiPoint/MultiLineString/MultiPolygon if they are\n * all of the same type.\n *\n * @api\n */\nclass KML extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    if (!DEFAULT_STYLE_ARRAY) {\n      createStyleDefaults();\n    }\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {Array<Style>}\n     */\n    this.defaultStyle_ = options.defaultStyle\n      ? options.defaultStyle\n      : DEFAULT_STYLE_ARRAY;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.extractStyles_ =\n      options.extractStyles !== undefined ? options.extractStyles : true;\n\n    /**\n     * @type {boolean}\n     */\n    this.writeStyles_ =\n      options.writeStyles !== undefined ? options.writeStyles : true;\n\n    /**\n     * @private\n     * @type {!Object<string, (Array<Style>|string)>}\n     */\n    this.sharedStyles_ = {};\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.showPointNames_ =\n      options.showPointNames !== undefined ? options.showPointNames : true;\n\n    /**\n     * @type {null|string}\n     */\n    this.crossOrigin_ =\n      options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';\n\n    /**\n     * @type {IconUrlFunction}\n     */\n    this.iconUrlFunction_ = options.iconUrlFunction\n      ? options.iconUrlFunction\n      : defaultIconUrlFunction;\n\n    this.supportedMediaTypes = ['application/vnd.google-earth.kml+xml'];\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Array<Feature>|undefined} Features.\n   */\n  readDocumentOrFolder_(node, objectStack) {\n    // FIXME use scope somehow\n    const parsersNS = makeStructureNS(NAMESPACE_URIS, {\n      'Document': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Folder': makeArrayExtender(this.readDocumentOrFolder_, this),\n      'Placemark': makeArrayPusher(this.readPlacemark_, this),\n      'Style': this.readSharedStyle_.bind(this),\n      'StyleMap': this.readSharedStyleMap_.bind(this),\n    });\n    /** @type {Array<Feature>} */\n    // @ts-ignore\n    const features = pushParseAndPop([], parsersNS, node, objectStack, this);\n    if (features) {\n      return features;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   * @return {Feature|undefined} Feature.\n   */\n  readPlacemark_(node, objectStack) {\n    const object = pushParseAndPop(\n      {'geometry': null},\n      PLACEMARK_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (!object) {\n      return undefined;\n    }\n    const feature = new Feature();\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      feature.setId(id);\n    }\n    const options = /** @type {import(\"./Feature.js\").ReadOptions} */ (\n      objectStack[0]\n    );\n\n    const geometry = object['geometry'];\n    if (geometry) {\n      transformGeometryWithOptions(geometry, false, options);\n    }\n    feature.setGeometry(geometry);\n    delete object['geometry'];\n\n    if (this.extractStyles_) {\n      const style = object['Style'];\n      const styleUrl = object['styleUrl'];\n      const styleFunction = createFeatureStyleFunction(\n        style,\n        styleUrl,\n        this.defaultStyle_,\n        this.sharedStyles_,\n        this.showPointNames_,\n      );\n      feature.setStyle(styleFunction);\n    }\n    delete object['Style'];\n    // we do not remove the styleUrl property from the object, so it\n    // gets stored on feature when setProperties is called\n\n    feature.setProperties(object, true);\n\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyle_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id !== null) {\n      const style = readStyle.call(this, node, objectStack);\n      if (style) {\n        let styleUri;\n        let baseURI = node.baseURI;\n        if (!baseURI || baseURI == 'about:blank') {\n          baseURI = window.location.href;\n        }\n        if (baseURI) {\n          const url = new URL('#' + id, baseURI);\n          styleUri = url.href;\n        } else {\n          styleUri = '#' + id;\n        }\n        this.sharedStyles_[styleUri] = style;\n      }\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @private\n   */\n  readSharedStyleMap_(node, objectStack) {\n    const id = node.getAttribute('id');\n    if (id === null) {\n      return;\n    }\n    const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n    if (!styleMapValue) {\n      return;\n    }\n    let styleUri;\n    let baseURI = node.baseURI;\n    if (!baseURI || baseURI == 'about:blank') {\n      baseURI = window.location.href;\n    }\n    if (baseURI) {\n      const url = new URL('#' + id, baseURI);\n      styleUri = url.href;\n    } else {\n      styleUri = '#' + id;\n    }\n    this.sharedStyles_[styleUri] = styleMapValue;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return null;\n    }\n    const feature = this.readPlacemark_(node, [\n      this.getReadOptions(node, options),\n    ]);\n    if (feature) {\n      return feature;\n    }\n    return null;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    if (!NAMESPACE_URIS.includes(node.namespaceURI)) {\n      return [];\n    }\n    let features;\n    const localName = node.localName;\n    if (localName == 'Document' || localName == 'Folder') {\n      features = this.readDocumentOrFolder_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (features) {\n        return features;\n      }\n      return [];\n    }\n    if (localName == 'Placemark') {\n      const feature = this.readPlacemark_(node, [\n        this.getReadOptions(node, options),\n      ]);\n      if (feature) {\n        return [feature];\n      }\n      return [];\n    }\n    if (localName == 'kml') {\n      features = [];\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        const fs = this.readFeaturesFromNode(n, options);\n        if (fs) {\n          extend(features, fs);\n        }\n      }\n      return features;\n    }\n    return [];\n  }\n\n  /**\n   * Read the name of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {string|undefined} Name.\n   * @api\n   */\n  readName(source) {\n    if (!source) {\n      return undefined;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readNameFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readNameFromDocument(/** @type {Document} */ (source));\n    }\n    return this.readNameFromNode(/** @type {Element} */ (source));\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {string|undefined} Name.\n   */\n  readNameFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        const name = this.readNameFromNode(/** @type {Element} */ (n));\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {string|undefined} Name.\n   */\n  readNameFromNode(node) {\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'name') {\n        return readString(n);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' ||\n          localName == 'Folder' ||\n          localName == 'Placemark' ||\n          localName == 'kml')\n      ) {\n        const name = this.readNameFromNode(n);\n        if (name) {\n          return name;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Read the network links of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Network links.\n   * @api\n   */\n  readNetworkLinks(source) {\n    const networkLinks = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(networkLinks, this.readNetworkLinksFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromDocument(/** @type {Document} */ (source)),\n      );\n    } else {\n      extend(\n        networkLinks,\n        this.readNetworkLinksFromNode(/** @type {Element} */ (source)),\n      );\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromDocument(doc) {\n    const networkLinks = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(\n          networkLinks,\n          this.readNetworkLinksFromNode(/** @type {Element} */ (n)),\n        );\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Network links.\n   */\n  readNetworkLinksFromNode(node) {\n    const networkLinks = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        n.localName == 'NetworkLink'\n      ) {\n        const obj = pushParseAndPop({}, NETWORK_LINK_PARSERS, n, []);\n        networkLinks.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(networkLinks, this.readNetworkLinksFromNode(n));\n      }\n    }\n    return networkLinks;\n  }\n\n  /**\n   * Read the regions of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<Object>} Regions.\n   * @api\n   */\n  readRegion(source) {\n    const regions = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(regions, this.readRegionFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        regions,\n        this.readRegionFromDocument(/** @type {Document} */ (source)),\n      );\n    } else {\n      extend(regions, this.readRegionFromNode(/** @type {Element} */ (source)));\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<Object>} Region.\n   */\n  readRegionFromDocument(doc) {\n    const regions = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        extend(regions, this.readRegionFromNode(/** @type {Element} */ (n)));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<Object>} Region.\n   * @api\n   */\n  readRegionFromNode(node) {\n    const regions = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName == 'Region') {\n        const obj = pushParseAndPop({}, REGION_PARSERS, n, []);\n        regions.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName == 'Document' || localName == 'Folder' || localName == 'kml')\n      ) {\n        extend(regions, this.readRegionFromNode(n));\n      }\n    }\n    return regions;\n  }\n\n  /**\n   * @typedef {Object} KMLCamera Specifies the observer's viewpoint and associated view parameters.\n   * @property {number} [Latitude] Latitude of the camera.\n   * @property {number} [Longitude] Longitude of the camera.\n   * @property {number} [Altitude] Altitude of the camera.\n   * @property {string} [AltitudeMode] Floor-related altitude mode.\n   * @property {number} [Heading] Horizontal camera rotation.\n   * @property {number} [Tilt] Lateral camera rotation.\n   * @property {number} [Roll] Vertical camera rotation.\n   */\n\n  /**\n   * Read the cameras of the KML.\n   *\n   * @param {Document|Element|string} source Source.\n   * @return {Array<KMLCamera>} Cameras.\n   * @api\n   */\n  readCamera(source) {\n    const cameras = [];\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      extend(cameras, this.readCameraFromDocument(doc));\n    } else if (isDocument(source)) {\n      extend(\n        cameras,\n        this.readCameraFromDocument(/** @type {Document} */ (source)),\n      );\n    } else {\n      extend(cameras, this.readCameraFromNode(/** @type {Element} */ (source)));\n    }\n    return cameras;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {Array<KMLCamera>} Cameras.\n   */\n  readCameraFromDocument(doc) {\n    const cameras = [];\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType === Node.ELEMENT_NODE) {\n        extend(cameras, this.readCameraFromNode(/** @type {Element} */ (n)));\n      }\n    }\n    return cameras;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {Array<KMLCamera>} Cameras.\n   * @api\n   */\n  readCameraFromNode(node) {\n    const cameras = [];\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      if (NAMESPACE_URIS.includes(n.namespaceURI) && n.localName === 'Camera') {\n        const obj = pushParseAndPop({}, CAMERA_PARSERS, n, []);\n        cameras.push(obj);\n      }\n    }\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      const localName = n.localName;\n      if (\n        NAMESPACE_URIS.includes(n.namespaceURI) &&\n        (localName === 'Document' ||\n          localName === 'Folder' ||\n          localName === 'Placemark' ||\n          localName === 'kml')\n      ) {\n        extend(cameras, this.readCameraFromNode(n));\n      }\n    }\n    return cameras;\n  }\n\n  /**\n   * Encode an array of features in the KML format as an XML node. GeometryCollections,\n   * MultiPoints, MultiLineStrings, and MultiPolygons are output as MultiGeometries.\n   *\n   * @param {Array<Feature>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const kml = createElementNS(NAMESPACE_URIS[4], 'kml');\n    const xmlnsUri = 'http://www.w3.org/2000/xmlns/';\n    kml.setAttributeNS(xmlnsUri, 'xmlns:gx', GX_NAMESPACE_URIS[0]);\n    kml.setAttributeNS(xmlnsUri, 'xmlns:xsi', XML_SCHEMA_INSTANCE_URI);\n    kml.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATION,\n    );\n\n    const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {\n        node: kml,\n      };\n    /** @type {!Object<string, (Array<Feature>|Feature|undefined)>} */\n    const properties = {};\n    if (features.length > 1) {\n      properties['Document'] = features;\n    } else if (features.length == 1) {\n      properties['Placemark'] = features[0];\n    }\n    const orderedKeys = KML_SEQUENCE[kml.namespaceURI];\n    const values = makeSequence(properties, orderedKeys);\n    pushSerializeAndPop(\n      context,\n      KML_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      [options],\n      orderedKeys,\n      this,\n    );\n    return kml;\n  }\n}\n\n/**\n * @param {Style|undefined} foundStyle Style.\n * @param {string} name Name.\n * @return {Style} style Style.\n */\nfunction createNameStyleFunction(foundStyle, name) {\n  const textOffset = [0, 0];\n  /** @type {CanvasTextAlign} */\n  let textAlign = 'start';\n  const imageStyle = foundStyle.getImage();\n  if (imageStyle) {\n    const imageSize = imageStyle.getSize();\n    if (imageSize && imageSize.length == 2) {\n      const imageScale = imageStyle.getScaleArray();\n      const anchor = imageStyle.getAnchor();\n      // Offset the label to be centered to the right of the icon,\n      // if there is one.\n      textOffset[0] = imageScale[0] * (imageSize[0] - anchor[0]);\n      textOffset[1] = imageScale[1] * (imageSize[1] / 2 - anchor[1]);\n      textAlign = 'left';\n    }\n  }\n  let textStyle = foundStyle.getText();\n  if (textStyle) {\n    // clone the text style, customizing it with name, alignments and offset.\n    // Note that kml does not support many text options that OpenLayers does (rotation, textBaseline).\n    textStyle = textStyle.clone();\n    textStyle.setFont(textStyle.getFont() || DEFAULT_TEXT_STYLE.getFont());\n    textStyle.setScale(textStyle.getScale() || DEFAULT_TEXT_STYLE.getScale());\n    textStyle.setFill(textStyle.getFill() || DEFAULT_TEXT_STYLE.getFill());\n    textStyle.setStroke(textStyle.getStroke() || DEFAULT_TEXT_STROKE_STYLE);\n  } else {\n    textStyle = DEFAULT_TEXT_STYLE.clone();\n  }\n  textStyle.setText(name);\n  textStyle.setOffsetX(textOffset[0]);\n  textStyle.setOffsetY(textOffset[1]);\n  textStyle.setTextAlign(textAlign);\n\n  const nameStyle = new Style({\n    image: imageStyle,\n    text: textStyle,\n  });\n  return nameStyle;\n}\n\n/**\n * @param {Array<Style>|undefined} style Style.\n * @param {string} styleUrl Style URL.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles Shared styles.\n * @param {boolean|undefined} showPointNames true to show names for point placemarks.\n * @return {import(\"../style/Style.js\").StyleFunction} Feature style function.\n */\nfunction createFeatureStyleFunction(\n  style,\n  styleUrl,\n  defaultStyle,\n  sharedStyles,\n  showPointNames,\n) {\n  return (\n    /**\n     * @param {Feature} feature feature.\n     * @param {number} resolution Resolution.\n     * @return {Array<Style>|Style} Style.\n     */\n    function (feature, resolution) {\n      let drawName = showPointNames;\n      let name = '';\n      let multiGeometryPoints = [];\n      if (drawName) {\n        const geometry = feature.getGeometry();\n        if (geometry) {\n          if (geometry instanceof GeometryCollection) {\n            multiGeometryPoints = geometry\n              .getGeometriesArrayRecursive()\n              .filter(function (geometry) {\n                const type = geometry.getType();\n                return type === 'Point' || type === 'MultiPoint';\n              });\n            drawName = multiGeometryPoints.length > 0;\n          } else {\n            const type = geometry.getType();\n            drawName = type === 'Point' || type === 'MultiPoint';\n          }\n        }\n      }\n\n      if (drawName) {\n        name = /** @type {string} */ (feature.get('name'));\n        drawName = drawName && !!name;\n        // convert any html character codes\n        if (drawName && /&[^&]+;/.test(name)) {\n          if (!TEXTAREA) {\n            TEXTAREA = document.createElement('textarea');\n          }\n          TEXTAREA.innerHTML = name;\n          name = TEXTAREA.value;\n        }\n      }\n\n      let featureStyle = defaultStyle;\n      if (style) {\n        featureStyle = style;\n      } else if (styleUrl) {\n        featureStyle = findStyle(styleUrl, defaultStyle, sharedStyles);\n      }\n      if (drawName) {\n        const nameStyle = createNameStyleFunction(featureStyle[0], name);\n        if (multiGeometryPoints.length > 0) {\n          // in multigeometries restrict the name style to points and create a\n          // style without image or text for geometries requiring fill or stroke\n          // including any polygon specific style if there is one\n          nameStyle.setGeometry(new GeometryCollection(multiGeometryPoints));\n          const baseStyle = new Style({\n            geometry: featureStyle[0].getGeometry(),\n            image: null,\n            fill: featureStyle[0].getFill(),\n            stroke: featureStyle[0].getStroke(),\n            text: null,\n          });\n          return [nameStyle, baseStyle].concat(featureStyle.slice(1));\n        }\n        return nameStyle;\n      }\n      return featureStyle;\n    }\n  );\n}\n\n/**\n * @param {Array<Style>|string|undefined} styleValue Style value.\n * @param {Array<Style>} defaultStyle Default style.\n * @param {!Object<string, (Array<Style>|string)>} sharedStyles\n * Shared styles.\n * @return {Array<Style>} Style.\n */\nfunction findStyle(styleValue, defaultStyle, sharedStyles) {\n  if (Array.isArray(styleValue)) {\n    return styleValue;\n  }\n  if (typeof styleValue === 'string') {\n    return findStyle(sharedStyles[styleValue], defaultStyle, sharedStyles);\n  }\n  return defaultStyle;\n}\n\n/**\n * @param {Node} node Node.\n * @return {import(\"../color.js\").Color|undefined} Color.\n */\nfunction readColor(node) {\n  const s = getAllTextContent(node, false);\n  // The KML specification states that colors should not include a leading `#`\n  // but we tolerate them.\n  const m = /^\\s*#?\\s*([0-9A-Fa-f]{8})\\s*$/.exec(s);\n  if (m) {\n    const hexColor = m[1];\n    return [\n      parseInt(hexColor.substr(6, 2), 16),\n      parseInt(hexColor.substr(4, 2), 16),\n      parseInt(hexColor.substr(2, 2), 16),\n      parseInt(hexColor.substr(0, 2), 16) / 255,\n    ];\n  }\n  return undefined;\n}\n\n/**\n * @param {Node} node Node.\n * @return {Array<number>|undefined} Flat coordinates.\n */\nexport function readFlatCoordinates(node) {\n  let s = getAllTextContent(node, false);\n  const flatCoordinates = [];\n  // The KML specification states that coordinate tuples should not include\n  // spaces, but we tolerate them.\n  s = s.replace(/\\s*,\\s*/g, ',');\n  const re =\n    /^\\s*([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?),([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|,|$)(?:([+\\-]?\\d*\\.?\\d+(?:e[+\\-]?\\d+)?)(?:\\s+|$))?\\s*/i;\n  let m;\n  while ((m = re.exec(s))) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = m[3] ? parseFloat(m[3]) : 0;\n    flatCoordinates.push(x, y, z);\n    s = s.substr(m[0].length);\n  }\n  if (s !== '') {\n    return undefined;\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readURI(node) {\n  const s = getAllTextContent(node, false).trim();\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  }\n  return s;\n}\n\n/**\n * @param {Node} node Node.\n * @return {string} URI.\n */\nfunction readStyleURL(node) {\n  // KML files in the wild occasionally forget the leading\n  // `#` on styleUrlsdefined in the same document.\n  const s = getAllTextContent(node, false)\n    .trim()\n    .replace(/^(?!.*#)/, '#');\n  let baseURI = node.baseURI;\n  if (!baseURI || baseURI == 'about:blank') {\n    baseURI = window.location.href;\n  }\n  if (baseURI) {\n    const url = new URL(s, baseURI);\n    return url.href;\n  }\n  return s;\n}\n\n/**\n * @param {Element} node Node.\n * @return {Vec2} Vec2.\n */\nfunction readVec2(node) {\n  const xunits = node.getAttribute('xunits');\n  const yunits = node.getAttribute('yunits');\n  /** @type {import('../style/Icon.js').IconOrigin} */\n  let origin;\n  if (xunits !== 'insetPixels') {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-left';\n    } else {\n      origin = 'top-left';\n    }\n  } else {\n    if (yunits !== 'insetPixels') {\n      origin = 'bottom-right';\n    } else {\n      origin = 'top-right';\n    }\n  }\n  return {\n    x: parseFloat(node.getAttribute('x')),\n    xunits: ICON_ANCHOR_UNITS_MAP[xunits],\n    y: parseFloat(node.getAttribute('y')),\n    yunits: ICON_ANCHOR_UNITS_MAP[yunits],\n    origin: origin,\n  };\n}\n\n/**\n * @param {Node} node Node.\n * @return {number|undefined} Scale.\n */\nfunction readScale(node) {\n  return readDecimal(node);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_MAP_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Pair': pairDataParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>|string|undefined} StyleMap.\n */\nfunction readStyleMapValue(node, objectStack) {\n  return pushParseAndPop(undefined, STYLE_MAP_PARSERS, node, objectStack, this);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeObjectPropertySetter(readIcon),\n  'color': makeObjectPropertySetter(readColor),\n  'heading': makeObjectPropertySetter(readDecimal),\n  'hotSpot': makeObjectPropertySetter(readVec2),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction iconStyleParser(node, objectStack) {\n  // FIXME refreshMode\n  // FIXME refreshInterval\n  // FIXME viewRefreshTime\n  // FIXME viewBoundScale\n  // FIXME viewFormat\n  // FIXME httpQuery\n  const object = pushParseAndPop({}, ICON_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const IconObject = 'Icon' in object ? object['Icon'] : {};\n  const drawIcon = !('Icon' in object) || Object.keys(IconObject).length > 0;\n  let src;\n  const href = /** @type {string|undefined} */ (IconObject['href']);\n  if (href) {\n    src = href;\n  } else if (drawIcon) {\n    src = DEFAULT_IMAGE_STYLE_SRC;\n  }\n  let anchor, anchorXUnits, anchorYUnits;\n  /** @type {import('../style/Icon.js').IconOrigin|undefined} */\n  let anchorOrigin = 'bottom-left';\n  const hotSpot = /** @type {Vec2|undefined} */ (object['hotSpot']);\n  if (hotSpot) {\n    anchor = [hotSpot.x, hotSpot.y];\n    anchorXUnits = hotSpot.xunits;\n    anchorYUnits = hotSpot.yunits;\n    anchorOrigin = hotSpot.origin;\n  } else if (/^https?:\\/\\/maps\\.(?:google|gstatic)\\.com\\//.test(src)) {\n    // Google hotspots from https://kml4earth.appspot.com/icons.html#notes\n    if (src.includes('pushpin')) {\n      anchor = DEFAULT_IMAGE_STYLE_ANCHOR;\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('arrow-reverse')) {\n      anchor = [54, 42];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    } else if (src.includes('paddle')) {\n      anchor = [32, 1];\n      anchorXUnits = DEFAULT_IMAGE_STYLE_ANCHOR_X_UNITS;\n      anchorYUnits = DEFAULT_IMAGE_STYLE_ANCHOR_Y_UNITS;\n    }\n  }\n\n  let offset;\n  const x = /** @type {number|undefined} */ (IconObject['x']);\n  const y = /** @type {number|undefined} */ (IconObject['y']);\n  if (x !== undefined && y !== undefined) {\n    offset = [x, y];\n  }\n\n  let size;\n  const w = /** @type {number|undefined} */ (IconObject['w']);\n  const h = /** @type {number|undefined} */ (IconObject['h']);\n  if (w !== undefined && h !== undefined) {\n    size = [w, h];\n  }\n\n  let rotation;\n  const heading = /** @type {number} */ (object['heading']);\n  if (heading !== undefined) {\n    rotation = toRadians(heading);\n  }\n\n  const scale = /** @type {number|undefined} */ (object['scale']);\n\n  const color = /** @type {Array<number>|undefined} */ (object['color']);\n\n  if (drawIcon) {\n    if (src == DEFAULT_IMAGE_STYLE_SRC) {\n      size = DEFAULT_IMAGE_STYLE_SIZE;\n    }\n\n    const imageStyle = new Icon({\n      anchor: anchor,\n      anchorOrigin: anchorOrigin,\n      anchorXUnits: anchorXUnits,\n      anchorYUnits: anchorYUnits,\n      crossOrigin: this.crossOrigin_,\n      offset: offset,\n      offsetOrigin: 'bottom-left',\n      rotation: rotation,\n      scale: scale,\n      size: size,\n      src: this.iconUrlFunction_(src),\n      color: color,\n    });\n\n    const imageScale = imageStyle.getScaleArray()[0];\n    const imageSize = imageStyle.getSize();\n    if (imageSize === null) {\n      const imageState = imageStyle.getImageState();\n      if (imageState === ImageState.IDLE || imageState === ImageState.LOADING) {\n        const listener = function () {\n          const imageState = imageStyle.getImageState();\n          if (\n            !(\n              imageState === ImageState.IDLE ||\n              imageState === ImageState.LOADING\n            )\n          ) {\n            const imageSize = imageStyle.getSize();\n            if (imageSize && imageSize.length == 2) {\n              const resizeScale = scaleForSize(imageSize);\n              imageStyle.setScale(imageScale * resizeScale);\n            }\n            imageStyle.unlistenImageChange(listener);\n          }\n        };\n        imageStyle.listenImageChange(listener);\n        if (imageState === ImageState.IDLE) {\n          imageStyle.load();\n        }\n      }\n    } else if (imageSize.length == 2) {\n      const resizeScale = scaleForSize(imageSize);\n      imageStyle.setScale(imageScale * resizeScale);\n    }\n    styleObject['imageStyle'] = imageStyle;\n  } else {\n    // handle the case when we explicitly want to draw no icon.\n    styleObject['imageStyle'] = DEFAULT_NO_IMAGE_STYLE;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'scale': makeObjectPropertySetter(readScale),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction labelStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, LABEL_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const textStyle = new Text({\n    fill: new Fill({\n      color:\n        /** @type {import(\"../color.js\").Color} */\n        ('color' in object ? object['color'] : DEFAULT_COLOR),\n    }),\n    scale: /** @type {number|undefined} */ (object['scale']),\n  });\n  styleObject['textStyle'] = textStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LINE_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'width': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lineStyleParser(node, objectStack) {\n  // FIXME colorMode\n  // FIXME gx:outerColor\n  // FIXME gx:outerWidth\n  // FIXME gx:physicalWidth\n  // FIXME gx:labelVisibility\n  const object = pushParseAndPop({}, LINE_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const strokeStyle = new Stroke({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n    width: /** @type {number} */ ('width' in object ? object['width'] : 1),\n  });\n  styleObject['strokeStyle'] = strokeStyle;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst POLY_STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeObjectPropertySetter(readColor),\n  'fill': makeObjectPropertySetter(readBoolean),\n  'outline': makeObjectPropertySetter(readBoolean),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction polyStyleParser(node, objectStack) {\n  // FIXME colorMode\n  const object = pushParseAndPop({}, POLY_STYLE_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const styleObject = objectStack[objectStack.length - 1];\n  const fillStyle = new Fill({\n    color:\n      /** @type {import(\"../color.js\").Color} */\n      ('color' in object ? object['color'] : DEFAULT_COLOR),\n  });\n  styleObject['fillStyle'] = fillStyle;\n  const fill = /** @type {boolean|undefined} */ (object['fill']);\n  if (fill !== undefined) {\n    styleObject['fill'] = fill;\n  }\n  const outline = /** @type {boolean|undefined} */ (object['outline']);\n  if (outline !== undefined) {\n    styleObject['outline'] = outline;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RING_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} LinearRing flat coordinates.\n */\nfunction readFlatLinearRing(node, objectStack) {\n  return pushParseAndPop(null, FLAT_LINEAR_RING_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction gxCoordParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const coordinates = gxTrackObject.coordinates;\n  const s = getAllTextContent(node, false);\n  const re =\n    /^\\s*([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s+([+\\-]?\\d+(?:\\.\\d*)?(?:e[+\\-]?\\d*)?)\\s*$/i;\n  const m = re.exec(s);\n  if (m) {\n    const x = parseFloat(m[1]);\n    const y = parseFloat(m[2]);\n    const z = parseFloat(m[3]);\n    coordinates.push([x, y, z]);\n  } else {\n    coordinates.push([]);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_MULTITRACK_GEOMETRY_PARSERS = makeStructureNS(GX_NAMESPACE_URIS, {\n  'Track': makeArrayPusher(readGxTrack),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {MultiLineString|undefined} MultiLineString.\n */\nfunction readGxMultiTrack(node, objectStack) {\n  const lineStrings = pushParseAndPop(\n    [],\n    GX_MULTITRACK_GEOMETRY_PARSERS,\n    node,\n    objectStack,\n  );\n  if (!lineStrings) {\n    return undefined;\n  }\n  return new MultiLineString(lineStrings);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GX_TRACK_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'when': whenParser,\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'coord': gxCoordParser,\n  }),\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readGxTrack(node, objectStack) {\n  const gxTrackObject = pushParseAndPop(\n    /** @type {GxTrackObject} */ ({\n      coordinates: [],\n      whens: [],\n    }),\n    GX_TRACK_PARSERS,\n    node,\n    objectStack,\n  );\n  if (!gxTrackObject) {\n    return undefined;\n  }\n  const flatCoordinates = [];\n  const coordinates = gxTrackObject.coordinates;\n  const whens = gxTrackObject.whens;\n  for (\n    let i = 0, ii = Math.min(coordinates.length, whens.length);\n    i < ii;\n    ++i\n  ) {\n    if (coordinates[i].length == 3) {\n      flatCoordinates.push(\n        coordinates[i][0],\n        coordinates[i][1],\n        coordinates[i][2],\n        whens[i],\n      );\n    }\n  }\n  return new LineString(flatCoordinates, 'XYZM');\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst ICON_PARSERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeObjectPropertySetter(readURI),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeObjectPropertySetter(readDecimal),\n    'y': makeObjectPropertySetter(readDecimal),\n    'w': makeObjectPropertySetter(readDecimal),\n    'h': makeObjectPropertySetter(readDecimal),\n  }),\n);\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object} Icon object.\n */\nfunction readIcon(node, objectStack) {\n  const iconObject = pushParseAndPop({}, ICON_PARSERS, node, objectStack);\n  if (iconObject) {\n    return iconObject;\n  }\n  return null;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst GEOMETRY_FLAT_COORDINATES_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'coordinates': makeReplacer(readFlatCoordinates),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<number>} Flat coordinates.\n */\nfunction readFlatCoordinatesFromNode(node, objectStack) {\n  return pushParseAndPop(\n    null,\n    GEOMETRY_FLAT_COORDINATES_PARSERS,\n    node,\n    objectStack,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTRUDE_AND_ALTITUDE_MODE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeObjectPropertySetter(readBoolean),\n  'tessellate': makeObjectPropertySetter(readBoolean),\n  'altitudeMode': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {LineString|undefined} LineString.\n */\nfunction readLineString(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack,\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const lineString = new LineString(flatCoordinates, 'XYZ');\n    lineString.setProperties(properties, true);\n    return lineString;\n  }\n  return undefined;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readLinearRing(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack,\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const polygon = new Polygon(flatCoordinates, 'XYZ', [\n      flatCoordinates.length,\n    ]);\n    polygon.setProperties(properties, true);\n    return polygon;\n  }\n  return undefined;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeArrayPusher(readLineString),\n  'LinearRing': makeArrayPusher(readLinearRing),\n  'MultiGeometry': makeArrayPusher(readMultiGeometry),\n  'Point': makeArrayPusher(readPoint),\n  'Polygon': makeArrayPusher(readPolygon),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readMultiGeometry(node, objectStack) {\n  const geometries = pushParseAndPop(\n    [],\n    MULTI_GEOMETRY_PARSERS,\n    node,\n    objectStack,\n  );\n  if (!geometries) {\n    return null;\n  }\n  if (geometries.length === 0) {\n    return new GeometryCollection(geometries);\n  }\n  let multiGeometry;\n  let homogeneous = true;\n  const type = geometries[0].getType();\n  let geometry;\n  for (let i = 1, ii = geometries.length; i < ii; ++i) {\n    geometry = geometries[i];\n    if (geometry.getType() != type) {\n      homogeneous = false;\n      break;\n    }\n  }\n  if (homogeneous) {\n    let layout;\n    let flatCoordinates;\n    if (type == 'Point') {\n      const point = geometries[0];\n      layout = point.getLayout();\n      flatCoordinates = point.getFlatCoordinates();\n      for (let i = 1, ii = geometries.length; i < ii; ++i) {\n        geometry = geometries[i];\n        extend(flatCoordinates, geometry.getFlatCoordinates());\n      }\n      multiGeometry = new MultiPoint(flatCoordinates, layout);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'LineString') {\n      multiGeometry = new MultiLineString(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'Polygon') {\n      multiGeometry = new MultiPolygon(geometries);\n      setCommonGeometryProperties(multiGeometry, geometries);\n    } else if (type == 'GeometryCollection') {\n      multiGeometry = new GeometryCollection(geometries);\n    } else {\n      throw new Error('Unknown geometry type found');\n    }\n  } else {\n    multiGeometry = new GeometryCollection(geometries);\n  }\n  return /** @type {import(\"../geom/Geometry.js\").default} */ (multiGeometry);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Point|undefined} Point.\n */\nfunction readPoint(node, objectStack) {\n  const properties = pushParseAndPop(\n    {},\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack,\n  );\n  const flatCoordinates = readFlatCoordinatesFromNode(node, objectStack);\n  if (flatCoordinates) {\n    const point = new Point(flatCoordinates, 'XYZ');\n    point.setProperties(properties, true);\n    return point;\n  }\n  return undefined;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst FLAT_LINEAR_RINGS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'innerBoundaryIs': innerBoundaryIsParser,\n  'outerBoundaryIs': outerBoundaryIsParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Polygon|undefined} Polygon.\n */\nfunction readPolygon(node, objectStack) {\n  const properties = pushParseAndPop(\n    /** @type {Object<string,*>} */ ({}),\n    EXTRUDE_AND_ALTITUDE_MODE_PARSERS,\n    node,\n    objectStack,\n  );\n  const flatLinearRings = pushParseAndPop(\n    [null],\n    FLAT_LINEAR_RINGS_PARSERS,\n    node,\n    objectStack,\n  );\n  if (flatLinearRings && flatLinearRings[0]) {\n    const flatCoordinates = flatLinearRings[0];\n    const ends = [flatCoordinates.length];\n    for (let i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n      extend(flatCoordinates, flatLinearRings[i]);\n      ends.push(flatCoordinates.length);\n    }\n    const polygon = new Polygon(flatCoordinates, 'XYZ', ends);\n    polygon.setProperties(properties, true);\n    return polygon;\n  }\n  return undefined;\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': iconStyleParser,\n  'LabelStyle': labelStyleParser,\n  'LineStyle': lineStyleParser,\n  'PolyStyle': polyStyleParser,\n});\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<Style>} Style.\n */\nfunction readStyle(node, objectStack) {\n  const styleObject = pushParseAndPop(\n    {},\n    STYLE_PARSERS,\n    node,\n    objectStack,\n    this,\n  );\n  if (!styleObject) {\n    return null;\n  }\n  let fillStyle =\n    /** @type {Fill} */\n    (\n      'fillStyle' in styleObject ? styleObject['fillStyle'] : DEFAULT_FILL_STYLE\n    );\n  const fill = /** @type {boolean|undefined} */ (styleObject['fill']);\n  if (fill !== undefined && !fill) {\n    fillStyle = null;\n  }\n  let imageStyle;\n  if ('imageStyle' in styleObject) {\n    if (styleObject['imageStyle'] != DEFAULT_NO_IMAGE_STYLE) {\n      imageStyle = /** @type {import(\"../style/Image.js\").default} */ (\n        styleObject['imageStyle']\n      );\n    }\n  } else {\n    imageStyle = DEFAULT_IMAGE_STYLE;\n  }\n  const textStyle =\n    /** @type {Text} */\n    (\n      'textStyle' in styleObject ? styleObject['textStyle'] : DEFAULT_TEXT_STYLE\n    );\n  const strokeStyle =\n    /** @type {Stroke} */\n    (\n      'strokeStyle' in styleObject\n        ? styleObject['strokeStyle']\n        : DEFAULT_STROKE_STYLE\n    );\n  const outline = /** @type {boolean|undefined} */ (styleObject['outline']);\n  if (outline !== undefined && !outline) {\n    // if the polystyle specifies no outline two styles are needed,\n    // one for non-polygon geometries where linestrings require a stroke\n    // and one for polygons where there should be no stroke\n    return [\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type !== 'Polygon' && type !== 'MultiPolygon';\n                }),\n            );\n          }\n          if (type !== 'Polygon' && type !== 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        image: imageStyle,\n        stroke: strokeStyle,\n        text: textStyle,\n        zIndex: undefined, // FIXME\n      }),\n      new Style({\n        geometry: function (feature) {\n          const geometry = feature.getGeometry();\n          const type = geometry.getType();\n          if (type === 'GeometryCollection') {\n            const collection =\n              /** @type {import(\"../geom/GeometryCollection\").default} */ (\n                geometry\n              );\n            return new GeometryCollection(\n              collection\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Polygon' || type === 'MultiPolygon';\n                }),\n            );\n          }\n          if (type === 'Polygon' || type === 'MultiPolygon') {\n            return geometry;\n          }\n        },\n        fill: fillStyle,\n        stroke: null,\n        zIndex: undefined, // FIXME\n      }),\n    ];\n  }\n  return [\n    new Style({\n      fill: fillStyle,\n      image: imageStyle,\n      stroke: strokeStyle,\n      text: textStyle,\n      zIndex: undefined, // FIXME\n    }),\n  ];\n}\n\n/**\n * Reads an array of geometries and creates arrays for common geometry\n * properties. Then sets them to the multi geometry.\n * @param {MultiPoint|MultiLineString|MultiPolygon} multiGeometry A multi-geometry.\n * @param {Array<import(\"../geom/Geometry.js\").default>} geometries List of geometries.\n */\nfunction setCommonGeometryProperties(multiGeometry, geometries) {\n  const ii = geometries.length;\n  const extrudes = new Array(geometries.length);\n  const tessellates = new Array(geometries.length);\n  const altitudeModes = new Array(geometries.length);\n  let hasExtrude, hasTessellate, hasAltitudeMode;\n  hasExtrude = false;\n  hasTessellate = false;\n  hasAltitudeMode = false;\n  for (let i = 0; i < ii; ++i) {\n    const geometry = geometries[i];\n    extrudes[i] = geometry.get('extrude');\n    tessellates[i] = geometry.get('tessellate');\n    altitudeModes[i] = geometry.get('altitudeMode');\n    hasExtrude = hasExtrude || extrudes[i] !== undefined;\n    hasTessellate = hasTessellate || tessellates[i] !== undefined;\n    hasAltitudeMode = hasAltitudeMode || altitudeModes[i];\n  }\n  if (hasExtrude) {\n    multiGeometry.set('extrude', extrudes);\n  }\n  if (hasTessellate) {\n    multiGeometry.set('tessellate', tessellates);\n  }\n  if (hasAltitudeMode) {\n    multiGeometry.set('altitudeMode', altitudeModes);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'displayName': makeObjectPropertySetter(readString),\n  'value': makeObjectPropertySetter(readString),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction dataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  parseNode(DATA_PARSERS, node, objectStack);\n  const featureObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  if (name && featureObject.displayName) {\n    featureObject[name] = {\n      value: featureObject.value,\n      displayName: featureObject.displayName,\n      toString: function () {\n        return featureObject.value;\n      },\n    };\n  } else if (name !== null) {\n    featureObject[name] = featureObject.value;\n  } else if (featureObject.displayName !== null) {\n    featureObject[featureObject.displayName] = featureObject.value;\n  }\n  delete featureObject['value'];\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst EXTENDED_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': dataParser,\n  'SchemaData': schemaDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction extendedDataParser(node, objectStack) {\n  parseNode(EXTENDED_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction regionParser(node, objectStack) {\n  parseNode(REGION_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst PAIR_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'Style': makeObjectPropertySetter(readStyle),\n  'key': makeObjectPropertySetter(readString),\n  'styleUrl': makeObjectPropertySetter(readStyleURL),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction pairDataParser(node, objectStack) {\n  const pairObject = pushParseAndPop({}, PAIR_PARSERS, node, objectStack, this);\n  if (!pairObject) {\n    return;\n  }\n  const key = /** @type {string|undefined} */ (pairObject['key']);\n  if (key && key == 'normal') {\n    const styleUrl = /** @type {string|undefined} */ (pairObject['styleUrl']);\n    if (styleUrl) {\n      objectStack[objectStack.length - 1] = styleUrl;\n    }\n    const style = /** @type {Style} */ (pairObject['Style']);\n    if (style) {\n      objectStack[objectStack.length - 1] = style;\n    }\n  }\n}\n\n/**\n * @this {KML}\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction placemarkStyleMapParser(node, objectStack) {\n  const styleMapValue = readStyleMapValue.call(this, node, objectStack);\n  if (!styleMapValue) {\n    return;\n  }\n  const placemarkObject = objectStack[objectStack.length - 1];\n  if (Array.isArray(styleMapValue)) {\n    placemarkObject['Style'] = styleMapValue;\n  } else if (typeof styleMapValue === 'string') {\n    placemarkObject['styleUrl'] = styleMapValue;\n  } else {\n    throw new Error('`styleMapValue` has an unknown type');\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst SCHEMA_DATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'SimpleData': simpleDataParser,\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction schemaDataParser(node, objectStack) {\n  parseNode(SCHEMA_DATA_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction simpleDataParser(node, objectStack) {\n  const name = node.getAttribute('name');\n  if (name !== null) {\n    const data = readString(node);\n    const featureObject = /** @type {Object} */ (\n      objectStack[objectStack.length - 1]\n    );\n    featureObject[name] = data;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LAT_LON_ALT_BOX_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'altitudeMode': makeObjectPropertySetter(readString),\n  'minAltitude': makeObjectPropertySetter(readDecimal),\n  'maxAltitude': makeObjectPropertySetter(readDecimal),\n  'north': makeObjectPropertySetter(readDecimal),\n  'south': makeObjectPropertySetter(readDecimal),\n  'east': makeObjectPropertySetter(readDecimal),\n  'west': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction latLonAltBoxParser(node, objectStack) {\n  const object = pushParseAndPop(\n    {},\n    LAT_LON_ALT_BOX_PARSERS,\n    node,\n    objectStack,\n  );\n  if (!object) {\n    return;\n  }\n  const regionObject = /** @type {Object} */ (\n    objectStack[objectStack.length - 1]\n  );\n  const extent = [\n    parseFloat(object['west']),\n    parseFloat(object['south']),\n    parseFloat(object['east']),\n    parseFloat(object['north']),\n  ];\n  regionObject['extent'] = extent;\n  regionObject['altitudeMode'] = object['altitudeMode'];\n  regionObject['minAltitude'] = parseFloat(object['minAltitude']);\n  regionObject['maxAltitude'] = parseFloat(object['maxAltitude']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst LOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'minLodPixels': makeObjectPropertySetter(readDecimal),\n  'maxLodPixels': makeObjectPropertySetter(readDecimal),\n  'minFadeExtent': makeObjectPropertySetter(readDecimal),\n  'maxFadeExtent': makeObjectPropertySetter(readDecimal),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction lodParser(node, objectStack) {\n  const object = pushParseAndPop({}, LOD_PARSERS, node, objectStack);\n  if (!object) {\n    return;\n  }\n  const lodObject = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  lodObject['minLodPixels'] = parseFloat(object['minLodPixels']);\n  lodObject['maxLodPixels'] = parseFloat(object['maxLodPixels']);\n  lodObject['minFadeExtent'] = parseFloat(object['minFadeExtent']);\n  lodObject['maxFadeExtent'] = parseFloat(object['maxFadeExtent']);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst INNER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  // KML spec only allows one LinearRing  per innerBoundaryIs, but Google Earth\n  // allows multiple, so we parse multiple here too.\n  'LinearRing': makeArrayPusher(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction innerBoundaryIsParser(node, objectStack) {\n  const innerBoundaryFlatLinearRings = pushParseAndPop(\n    /** @type {Array<Array<number>>} */ ([]),\n    INNER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack,\n  );\n  if (innerBoundaryFlatLinearRings.length > 0) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings.push(...innerBoundaryFlatLinearRings);\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\n// @ts-ignore\nconst OUTER_BOUNDARY_IS_PARSERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeReplacer(readFlatLinearRing),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction outerBoundaryIsParser(node, objectStack) {\n  /** @type {Array<number>|undefined} */\n  const flatLinearRing = pushParseAndPop(\n    undefined,\n    OUTER_BOUNDARY_IS_PARSERS,\n    node,\n    objectStack,\n  );\n  if (flatLinearRing) {\n    const flatLinearRings =\n      /** @type {Array<Array<number>>} */\n      (objectStack[objectStack.length - 1]);\n    flatLinearRings[0] = flatLinearRing;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction linkParser(node, objectStack) {\n  parseNode(LINK_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction whenParser(node, objectStack) {\n  const gxTrackObject =\n    /** @type {GxTrackObject} */\n    (objectStack[objectStack.length - 1]);\n  const whens = gxTrackObject.whens;\n  const s = getAllTextContent(node, false);\n  const when = Date.parse(s);\n  whens.push(isNaN(when) ? 0 : when);\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the color to.\n * @param {import(\"../color.js\").Color|string} color Color.\n */\nfunction writeColorTextNode(node, color) {\n  const rgba = asArray(color);\n  const opacity = rgba.length == 4 ? rgba[3] : 1;\n  /** @type {Array<string|number>} */\n  const abgr = [opacity * 255, rgba[2], rgba[1], rgba[0]];\n  for (let i = 0; i < 4; ++i) {\n    const hex = Math.floor(/** @type {number} */ (abgr[i])).toString(16);\n    abgr[i] = hex.length == 1 ? '0' + hex : hex;\n  }\n  writeStringTextNode(node, abgr.join(''));\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the coordinates to.\n * @param {Array<number>} coordinates Coordinates.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeCoordinatesTextNode(node, coordinates, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n\n  const layout = context['layout'];\n  const stride = context['stride'];\n\n  let dimension;\n  if (layout == 'XY' || layout == 'XYM') {\n    dimension = 2;\n  } else if (layout == 'XYZ' || layout == 'XYZM') {\n    dimension = 3;\n  } else {\n    throw new Error('Invalid geometry layout');\n  }\n\n  const ii = coordinates.length;\n  let text = '';\n  if (ii > 0) {\n    text += coordinates[0];\n    for (let d = 1; d < dimension; ++d) {\n      text += ',' + coordinates[d];\n    }\n    for (let i = stride; i < ii; i += stride) {\n      text += ' ' + coordinates[i];\n      for (let d = 1; d < dimension; ++d) {\n        text += ',' + coordinates[i + d];\n      }\n    }\n  }\n  writeStringTextNode(node, text);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst EXTENDEDDATA_NODE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Data': makeChildAppender(writeDataNode),\n  'value': makeChildAppender(writeDataNodeValue),\n  'displayName': makeChildAppender(writeDataNodeName),\n});\n\n/**\n * @param {Element} node Node.\n * @param {{name: *, value: *}} pair Name value pair.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeDataNode(node, pair, objectStack) {\n  node.setAttribute('name', pair.name);\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const value = pair.value;\n\n  if (typeof value == 'object') {\n    if (value !== null && value.displayName) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.displayName],\n        objectStack,\n        ['displayName'],\n      );\n    }\n\n    if (value !== null && value.value) {\n      pushSerializeAndPop(\n        context,\n        EXTENDEDDATA_NODE_SERIALIZERS,\n        OBJECT_PROPERTY_NODE_FACTORY,\n        [value.value],\n        objectStack,\n        ['value'],\n      );\n    }\n  } else {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      [value],\n      objectStack,\n      ['value'],\n    );\n  }\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the name to.\n * @param {string} name DisplayName.\n */\nfunction writeDataNodeName(node, name) {\n  writeCDATASection(node, name);\n}\n\n/**\n * @param {Node} node Node to append a CDATA Section with the value to.\n * @param {string} value Value.\n */\nfunction writeDataNodeValue(node, value) {\n  writeStringTextNode(node, value);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst DOCUMENT_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Placemark': makeChildAppender(writePlacemark),\n});\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst DOCUMENT_NODE_FACTORY = function (value, objectStack, nodeName) {\n  const parentNode = objectStack[objectStack.length - 1].node;\n  return createElementNS(parentNode.namespaceURI, 'Placemark');\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<Feature>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writeDocument(node, features, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    DOCUMENT_SERIALIZERS,\n    DOCUMENT_NODE_FACTORY,\n    features,\n    objectStack,\n    undefined,\n    this,\n  );\n}\n\n/**\n * A factory for creating Data nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst DATA_NODE_FACTORY = makeSimpleNodeFactory('Data');\n\n/**\n * @param {Element} node Node.\n * @param {{names: Array<string>, values: (Array<*>)}} namesAndValues Names and values.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeExtendedData(node, namesAndValues, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const names = namesAndValues.names;\n  const values = namesAndValues.values;\n  const length = names.length;\n\n  for (let i = 0; i < length; i++) {\n    pushSerializeAndPop(\n      context,\n      EXTENDEDDATA_NODE_SERIALIZERS,\n      DATA_NODE_FACTORY,\n      [{name: names[i], value: values[i]}],\n      objectStack,\n    );\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_SEQUENCE = makeStructureNS(\n  NAMESPACE_URIS,\n  ['href'],\n  makeStructureNS(GX_NAMESPACE_URIS, ['x', 'y', 'w', 'h']),\n);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_SERIALIZERS = makeStructureNS(\n  NAMESPACE_URIS,\n  {\n    'href': makeChildAppender(writeStringTextNode),\n  },\n  makeStructureNS(GX_NAMESPACE_URIS, {\n    'x': makeChildAppender(writeDecimalTextNode),\n    'y': makeChildAppender(writeDecimalTextNode),\n    'w': makeChildAppender(writeDecimalTextNode),\n    'h': makeChildAppender(writeDecimalTextNode),\n  }),\n);\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GX_NODE_FACTORY = function (value, objectStack, nodeName) {\n  return createElementNS(GX_NAMESPACE_URIS[0], 'gx:' + nodeName);\n};\n\n/**\n * @param {Element} node Node.\n * @param {Object} icon Icon object.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIcon(node, icon, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const parentNode = objectStack[objectStack.length - 1].node;\n  let orderedKeys = ICON_SEQUENCE[parentNode.namespaceURI];\n  let values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n  orderedKeys = ICON_SEQUENCE[GX_NAMESPACE_URIS[0]];\n  values = makeSequence(icon, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_SERIALIZERS,\n    GX_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'scale',\n  'heading',\n  'Icon',\n  'color',\n  'hotSpot',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst ICON_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'Icon': makeChildAppender(writeIcon),\n  'color': makeChildAppender(writeColorTextNode),\n  'heading': makeChildAppender(writeDecimalTextNode),\n  'hotSpot': makeChildAppender(writeVec2),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../style/Icon.js\").default} style Icon style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeIconStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const /** @type {Object<string, any>} */ properties = {};\n  const src = style.getSrc();\n  const size = style.getSize();\n  const iconImageSize = style.getImageSize();\n  const iconProperties = {\n    'href': src,\n  };\n\n  if (size) {\n    iconProperties['w'] = size[0];\n    iconProperties['h'] = size[1];\n    const anchor = style.getAnchor(); // top-left\n    const origin = style.getOrigin(); // top-left\n\n    if (origin && iconImageSize && origin[0] !== 0 && origin[1] !== size[1]) {\n      iconProperties['x'] = origin[0];\n      iconProperties['y'] = iconImageSize[1] - (origin[1] + size[1]);\n    }\n\n    if (anchor && (anchor[0] !== size[0] / 2 || anchor[1] !== size[1] / 2)) {\n      const /** @type {Vec2} */ hotSpot = {\n          x: anchor[0],\n          xunits: 'pixels',\n          y: size[1] - anchor[1],\n          yunits: 'pixels',\n        };\n      properties['hotSpot'] = hotSpot;\n    }\n  }\n\n  properties['Icon'] = iconProperties;\n\n  let scale = style.getScaleArray()[0];\n  let imageSize = size;\n  if (imageSize === null) {\n    imageSize = DEFAULT_IMAGE_STYLE_SIZE;\n  }\n  if (imageSize.length == 2) {\n    const resizeScale = scaleForSize(imageSize);\n    scale = scale / resizeScale;\n  }\n  if (scale !== 1) {\n    properties['scale'] = scale;\n  }\n\n  const rotation = style.getRotation();\n  if (rotation !== 0) {\n    properties['heading'] = rotation; // 0-360\n  }\n\n  const color = style.getColor();\n  if (color) {\n    properties['color'] = color;\n  }\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = ICON_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    ICON_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'scale',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LABEL_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'scale': makeChildAppender(writeScaleTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Text} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLabelStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  const fill = style.getFill();\n  if (fill) {\n    properties['color'] = fill.getColor();\n  }\n  const scale = style.getScale();\n  if (scale && scale !== 1) {\n    properties['scale'] = scale;\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LABEL_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LABEL_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, ['color', 'width']);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst LINE_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'width': makeChildAppender(writeDecimalTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Stroke} style style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeLineStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {\n    'color': style.getColor(),\n    'width': Number(style.getWidth()) || 1,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = LINE_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    LINE_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst GEOMETRY_TYPE_TO_NODENAME = {\n  'Point': 'Point',\n  'LineString': 'LineString',\n  'LinearRing': 'LinearRing',\n  'Polygon': 'Polygon',\n  'MultiPoint': 'MultiGeometry',\n  'MultiLineString': 'MultiGeometry',\n  'MultiPolygon': 'MultiGeometry',\n  'GeometryCollection': 'MultiGeometry',\n};\n\n/**\n * @const\n * @param {*} value Value.\n * @param {Array<*>} objectStack Object stack.\n * @param {string} [nodeName] Node name.\n * @return {Node|undefined} Node.\n */\nconst GEOMETRY_NODE_FACTORY = function (value, objectStack, nodeName) {\n  if (value) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      parentNode.namespaceURI,\n      GEOMETRY_TYPE_TO_NODENAME[\n        /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType()\n      ],\n    );\n  }\n};\n\n/**\n * A factory for creating Point nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POINT_NODE_FACTORY = makeSimpleNodeFactory('Point');\n\n/**\n * A factory for creating LineString nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINE_STRING_NODE_FACTORY = makeSimpleNodeFactory('LineString');\n\n/**\n * A factory for creating LinearRing nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst LINEAR_RING_NODE_FACTORY = makeSimpleNodeFactory('LinearRing');\n\n/**\n * A factory for creating Polygon nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst POLYGON_NODE_FACTORY = makeSimpleNodeFactory('Polygon');\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst MULTI_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'GeometryCollection': makeChildAppender(writeMultiGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeMultiGeometry(node, geometry, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const context = {node: node};\n  const type = geometry.getType();\n  /** @type {Array<import(\"../geom/Geometry.js\").default>} */\n  let geometries = [];\n  /** @type {function(*, Array<*>, string=): (Node|undefined)} */\n  let factory;\n  if (type === 'GeometryCollection') {\n    /** @type {GeometryCollection} */ (geometry)\n      .getGeometriesArrayRecursive()\n      .forEach(function (geometry) {\n        const type = geometry.getType();\n        if (type === 'MultiPoint') {\n          geometries = geometries.concat(\n            /** @type {MultiPoint} */ (geometry).getPoints(),\n          );\n        } else if (type === 'MultiLineString') {\n          geometries = geometries.concat(\n            /** @type {MultiLineString} */ (geometry).getLineStrings(),\n          );\n        } else if (type === 'MultiPolygon') {\n          geometries = geometries.concat(\n            /** @type {MultiPolygon} */ (geometry).getPolygons(),\n          );\n        } else if (\n          type === 'Point' ||\n          type === 'LineString' ||\n          type === 'Polygon'\n        ) {\n          geometries.push(geometry);\n        } else {\n          throw new Error('Unknown geometry type');\n        }\n      });\n    factory = GEOMETRY_NODE_FACTORY;\n  } else if (type === 'MultiPoint') {\n    geometries = /** @type {MultiPoint} */ (geometry).getPoints();\n    factory = POINT_NODE_FACTORY;\n  } else if (type === 'MultiLineString') {\n    geometries = /** @type {MultiLineString} */ (geometry).getLineStrings();\n    factory = LINE_STRING_NODE_FACTORY;\n  } else if (type === 'MultiPolygon') {\n    geometries = /** @type {MultiPolygon} */ (geometry).getPolygons();\n    factory = POLYGON_NODE_FACTORY;\n  } else {\n    throw new Error('Unknown geometry type');\n  }\n  pushSerializeAndPop(\n    context,\n    MULTI_GEOMETRY_SERIALIZERS,\n    factory,\n    geometries,\n    objectStack,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst BOUNDARY_IS_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/LinearRing.js\").default} linearRing Linear ring.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeBoundaryIs(node, linearRing, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  pushSerializeAndPop(\n    context,\n    BOUNDARY_IS_SERIALIZERS,\n    LINEAR_RING_NODE_FACTORY,\n    [linearRing],\n    objectStack,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PLACEMARK_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'ExtendedData': makeChildAppender(writeExtendedData),\n  'MultiGeometry': makeChildAppender(writeMultiGeometry),\n  'LineString': makeChildAppender(writePrimitiveGeometry),\n  'LinearRing': makeChildAppender(writePrimitiveGeometry),\n  'Point': makeChildAppender(writePrimitiveGeometry),\n  'Polygon': makeChildAppender(writePolygon),\n  'Style': makeChildAppender(writeStyle),\n  'address': makeChildAppender(writeStringTextNode),\n  'description': makeChildAppender(writeStringTextNode),\n  'name': makeChildAppender(writeStringTextNode),\n  'open': makeChildAppender(writeBooleanTextNode),\n  'phoneNumber': makeChildAppender(writeStringTextNode),\n  'styleUrl': makeChildAppender(writeStringTextNode),\n  'visibility': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PLACEMARK_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'name',\n  'open',\n  'visibility',\n  'address',\n  'phoneNumber',\n  'description',\n  'styleUrl',\n  'Style',\n]);\n\n/**\n * A factory for creating ExtendedData nodes.\n * @const\n * @type {function(*, Array<*>): (Node|undefined)}\n */\nconst EXTENDEDDATA_NODE_FACTORY = makeSimpleNodeFactory('ExtendedData');\n\n/**\n * FIXME currently we do serialize arbitrary/custom feature properties\n * (ExtendedData).\n * @param {Element} node Node.\n * @param {Feature} feature Feature.\n * @param {Array<*>} objectStack Object stack.\n * @this {KML}\n */\nfunction writePlacemark(node, feature, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n\n  // set id\n  if (feature.getId()) {\n    node.setAttribute('id', /** @type {string} */ (feature.getId()));\n  }\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = feature.getProperties();\n\n  // don't export these to ExtendedData\n  const filter = {\n    'address': 1,\n    'description': 1,\n    'name': 1,\n    'open': 1,\n    'phoneNumber': 1,\n    'styleUrl': 1,\n    'visibility': 1,\n  };\n  filter[feature.getGeometryName()] = 1;\n  const keys = Object.keys(properties || {})\n    .sort()\n    .filter(function (v) {\n      return !filter[v];\n    });\n\n  const styleFunction = feature.getStyleFunction();\n  if (styleFunction) {\n    // FIXME the styles returned by the style function are supposed to be\n    // resolution-independent here\n    const styles = styleFunction(feature, 0);\n    if (styles) {\n      const styleArray = Array.isArray(styles) ? styles : [styles];\n      let pointStyles = styleArray;\n      if (feature.getGeometry()) {\n        pointStyles = styleArray.filter(function (style) {\n          const geometry = style.getGeometryFunction()(feature);\n          if (geometry) {\n            const type = geometry.getType();\n            if (type === 'GeometryCollection') {\n              return /** @type {GeometryCollection} */ (geometry)\n                .getGeometriesArrayRecursive()\n                .filter(function (geometry) {\n                  const type = geometry.getType();\n                  return type === 'Point' || type === 'MultiPoint';\n                }).length;\n            }\n            return type === 'Point' || type === 'MultiPoint';\n          }\n        });\n        ('Point');\n      }\n      if (this.writeStyles_) {\n        let lineStyles = styleArray;\n        let polyStyles = styleArray;\n        if (feature.getGeometry()) {\n          lineStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'LineString' || type === 'MultiLineString';\n                  }).length;\n              }\n              return type === 'LineString' || type === 'MultiLineString';\n            }\n          });\n          polyStyles = styleArray.filter(function (style) {\n            const geometry = style.getGeometryFunction()(feature);\n            if (geometry) {\n              const type = geometry.getType();\n              if (type === 'GeometryCollection') {\n                return /** @type {GeometryCollection} */ (geometry)\n                  .getGeometriesArrayRecursive()\n                  .filter(function (geometry) {\n                    const type = geometry.getType();\n                    return type === 'Polygon' || type === 'MultiPolygon';\n                  }).length;\n              }\n              return type === 'Polygon' || type === 'MultiPolygon';\n            }\n          });\n        }\n        properties['Style'] = {\n          pointStyles: pointStyles,\n          lineStyles: lineStyles,\n          polyStyles: polyStyles,\n        };\n      }\n      if (pointStyles.length && properties['name'] === undefined) {\n        const textStyle = pointStyles[0].getText();\n        if (textStyle) {\n          properties['name'] = textStyle.getText();\n        }\n      }\n    }\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PLACEMARK_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n\n  if (keys.length > 0) {\n    const sequence = makeSequence(properties, keys);\n    const namesAndValues = {names: keys, values: sequence};\n    pushSerializeAndPop(\n      context,\n      PLACEMARK_SERIALIZERS,\n      EXTENDEDDATA_NODE_FACTORY,\n      [namesAndValues],\n      objectStack,\n    );\n  }\n\n  // serialize geometry\n  const options = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n    objectStack[0]\n  );\n  let geometry = feature.getGeometry();\n  if (geometry) {\n    geometry = transformGeometryWithOptions(geometry, true, options);\n  }\n  pushSerializeAndPop(\n    context,\n    PLACEMARK_SERIALIZERS,\n    GEOMETRY_NODE_FACTORY,\n    [geometry],\n    objectStack,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'extrude',\n  'tessellate',\n  'altitudeMode',\n  'coordinates',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst PRIMITIVE_GEOMETRY_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'extrude': makeChildAppender(writeBooleanTextNode),\n  'tessellate': makeChildAppender(writeBooleanTextNode),\n  'altitudeMode': makeChildAppender(writeStringTextNode),\n  'coordinates': makeChildAppender(writeCoordinatesTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePrimitiveGeometry(node, geometry, objectStack) {\n  const flatCoordinates = geometry.getFlatCoordinates();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  context['layout'] = geometry.getLayout();\n  context['stride'] = geometry.getStride();\n\n  // serialize properties (properties unknown to KML are not serialized)\n  const properties = geometry.getProperties();\n  properties.coordinates = flatCoordinates;\n\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = PRIMITIVE_GEOMETRY_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    PRIMITIVE_GEOMETRY_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'color',\n  'fill',\n  'outline',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLYGON_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'outerBoundaryIs': makeChildAppender(writeBoundaryIs),\n  'innerBoundaryIs': makeChildAppender(writeBoundaryIs),\n});\n\n/**\n * A factory for creating innerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst INNER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('innerBoundaryIs');\n\n/**\n * A factory for creating outerBoundaryIs nodes.\n * @const\n * @type {function(*, Array<*>, string=): (Node|undefined)}\n */\nconst OUTER_BOUNDARY_NODE_FACTORY = makeSimpleNodeFactory('outerBoundaryIs');\n\n/**\n * @param {Element} node Node.\n * @param {Polygon} polygon Polygon.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolygon(node, polygon, objectStack) {\n  const linearRings = polygon.getLinearRings();\n  const outerRing = linearRings.shift();\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  // inner rings\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    INNER_BOUNDARY_NODE_FACTORY,\n    linearRings,\n    objectStack,\n  );\n  // outer ring\n  pushSerializeAndPop(\n    context,\n    POLYGON_SERIALIZERS,\n    OUTER_BOUNDARY_NODE_FACTORY,\n    [outerRing],\n    objectStack,\n  );\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst POLY_STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'color': makeChildAppender(writeColorTextNode),\n  'fill': makeChildAppender(writeBooleanTextNode),\n  'outline': makeChildAppender(writeBooleanTextNode),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Style} style Style.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writePolyStyle(node, style, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const fill = style.getFill();\n  const stroke = style.getStroke();\n  const properties = {\n    'color': fill ? fill.getColor() : undefined,\n    'fill': fill ? undefined : false,\n    'outline': stroke ? undefined : false,\n  };\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = POLY_STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    POLY_STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @param {Node} node Node to append a TextNode with the scale to.\n * @param {number|undefined} scale Scale.\n */\nfunction writeScaleTextNode(node, scale) {\n  // the Math is to remove any excess decimals created by float arithmetic\n  writeDecimalTextNode(node, Math.round(scale * 1e6) / 1e6);\n}\n\n/**\n * @const\n * @type {Object<string, Array<string>>}\n */\n// @ts-ignore\nconst STYLE_SEQUENCE = makeStructureNS(NAMESPACE_URIS, [\n  'IconStyle',\n  'LabelStyle',\n  'LineStyle',\n  'PolyStyle',\n]);\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\n// @ts-ignore\nconst STYLE_SERIALIZERS = makeStructureNS(NAMESPACE_URIS, {\n  'IconStyle': makeChildAppender(writeIconStyle),\n  'LabelStyle': makeChildAppender(writeLabelStyle),\n  'LineStyle': makeChildAppender(writeLineStyle),\n  'PolyStyle': makeChildAppender(writePolyStyle),\n});\n\n/**\n * @param {Element} node Node.\n * @param {Object<string, Array<Style>>} styles Styles.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction writeStyle(node, styles, objectStack) {\n  const /** @type {import(\"../xml.js\").NodeStackItem} */ context = {node: node};\n  const properties = {};\n  if (styles.pointStyles.length) {\n    const textStyle = styles.pointStyles[0].getText();\n    if (textStyle) {\n      properties['LabelStyle'] = textStyle;\n    }\n    const imageStyle = styles.pointStyles[0].getImage();\n    if (\n      imageStyle &&\n      typeof (/** @type {?} */ (imageStyle).getSrc) === 'function'\n    ) {\n      properties['IconStyle'] = imageStyle;\n    }\n  }\n  if (styles.lineStyles.length) {\n    const strokeStyle = styles.lineStyles[0].getStroke();\n    if (strokeStyle) {\n      properties['LineStyle'] = strokeStyle;\n    }\n  }\n  if (styles.polyStyles.length) {\n    const strokeStyle = styles.polyStyles[0].getStroke();\n    if (strokeStyle && !properties['LineStyle']) {\n      properties['LineStyle'] = strokeStyle;\n    }\n    properties['PolyStyle'] = styles.polyStyles[0];\n  }\n  const parentNode = objectStack[objectStack.length - 1].node;\n  const orderedKeys = STYLE_SEQUENCE[parentNode.namespaceURI];\n  const values = makeSequence(properties, orderedKeys);\n  pushSerializeAndPop(\n    context,\n    STYLE_SERIALIZERS,\n    OBJECT_PROPERTY_NODE_FACTORY,\n    values,\n    objectStack,\n    orderedKeys,\n  );\n}\n\n/**\n * @param {Element} node Node to append a TextNode with the Vec2 to.\n * @param {Vec2} vec2 Vec2.\n */\nfunction writeVec2(node, vec2) {\n  node.setAttribute('x', String(vec2.x));\n  node.setAttribute('y', String(vec2.y));\n  node.setAttribute('xunits', vec2.xunits);\n  node.setAttribute('yunits', vec2.yunits);\n}\n\nexport default KML;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}