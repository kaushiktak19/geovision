{"ast":null,"code":"/**\n * @module ol/format/WFS\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GML32 from './GML32.js';\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport XMLFeature from './XMLFeature.js';\nimport { XML_SCHEMA_INSTANCE_URI, createElementNS, isDocument, makeArrayPusher, makeChildAppender, makeObjectPropertySetter, makeSimpleNodeFactory, parse, parseNode, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\nimport { and as andFilterFn, bbox as bboxFilterFn } from './filter.js';\nimport { assert } from '../asserts.js';\nimport { get as getProjection } from '../proj.js';\nimport { readNonNegativeIntegerString, readPositiveInteger, writeStringTextNode } from './xsd.js';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(GMLBase.prototype.readExtentElement, 'bounds')\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'member': makeArrayPusher(GMLBase.prototype.readFeaturesInternal)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger)\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds')\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'TransactionSummary': makeObjectPropertySetter(readTransactionSummary, 'transactionSummary'),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds')\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'PropertyName': makeChildAppender(writeStringTextNode)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative)\n  }\n};\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.\n * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to\n * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are\n * ignored.).\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`\n * option must be set.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} FeatureType\n * @property {!string} name The feature type name.\n * @property {!import(\"../extent.js\").Extent} bbox Extent to use for the BBOX filter.\n * @property {!string} geometryName Geometry name to use in the BBOX filter.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures NumberOfFeatures.\n * @property {import(\"../extent.js\").Extent} bounds Bounds.\n */\n\n/**\n * @typedef {Object} TransactionSummary\n * @property {number} totalDeleted TotalDeleted.\n * @property {number} totalInserted TotalInserted.\n * @property {number} totalUpdated TotalUpdated.\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {TransactionSummary} transactionSummary Transaction summary.\n * @property {Array<string>} insertIds InsertIds.\n */\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @type {Object<string, string>}\n */\nconst OGCNS = {\n  '2.0.0': 'http://www.opengis.net/ogc/1.1',\n  '1.1.0': 'http://www.opengis.net/ogc',\n  '1.0.0': 'http://www.opengis.net/ogc'\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst WFSNS = {\n  '2.0.0': 'http://www.opengis.net/wfs/2.0',\n  '1.1.0': 'http://www.opengis.net/wfs',\n  '1.0.0': 'http://www.opengis.net/wfs'\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst FESNS = {\n  '2.0.0': 'http://www.opengis.net/fes/2.0',\n  '1.1.0': 'http://www.opengis.net/fes',\n  '1.0.0': 'http://www.opengis.net/fes'\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '2.0.0': 'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',\n  '1.1.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0': 'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd'\n};\n\n/**\n * @type {Object<string, object>}\n */\nconst GML_FORMATS = {\n  '2.0.0': GML32,\n  '1.1.0': GML3,\n  '1.0.0': GML2\n};\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option to override the default.\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version ? options.version : DEFAULT_VERSION;\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML_FORMATS[this.version_]();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation ? options.schemaLocation : SCHEMA_LOCATIONS[this.version_];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node\n    };\n    Object.assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_\n    });\n    Object.assign(context, this.getReadOptions(node, options ? options : {}));\n    const objectStack = [context];\n    let featuresNS;\n    if (this.version_ === '2.0.0') {\n      featuresNS = FEATURE_COLLECTION_PARSERS;\n    } else {\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\n    }\n    let features = pushParseAndPop([], featuresNS, node, objectStack, this.gmlFormat_);\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument( /** @type {Document} */source);\n    }\n    return this.readTransactionResponseFromNode( /** @type {Element} */source);\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument( /** @type {Document} */source);\n    }\n    return this.readFeatureCollectionMetadataFromNode( /** @type {Element} */source);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode( /** @type {Element} */n);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(node.getAttribute('numberOfFeatures'));\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop( /** @type {FeatureCollectionMetadata} */result, FEATURE_COLLECTION_PARSERS, node, [], this.gmlFormat_);\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode( /** @type {Element} */n);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop( /** @type {TransactionResponse} */{}, TRANSACTION_RESPONSE_PARSERS, node, []);\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS[this.version_], 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', this.version_);\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', String(options.maxFeatures));\n    }\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', String(options.startIndex));\n    }\n    if (options.count !== undefined) {\n      node.setAttribute('count', String(options.count));\n    }\n    if (options.viewParams !== undefined) {\n      node.setAttribute('viewParams', options.viewParams);\n    }\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation_);\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node\n    };\n    Object.assign(context, {\n      'version': this.version_,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'propertyNames': options.propertyNames ? options.propertyNames : []\n    });\n    assert(Array.isArray(options.featureTypes), '`options.featureTypes` must be an Array');\n    if (typeof options.featureTypes[0] === 'string') {\n      let filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName, '`options.geometryName` must also be provided when `options.bbox` is set');\n        filter = this.combineBboxAndFilter(options.geometryName, options.bbox, options.srsName, filter);\n      }\n      Object.assign(context, {\n        'geometryName': options.geometryName,\n        'filter': filter\n      });\n      writeGetFeature(node, /** @type {!Array<string>} */options.featureTypes, [context]);\n    } else {\n      // Write one query node per element in featuresType.\n      options.featureTypes.forEach(( /** @type {FeatureType} */featureType) => {\n        const completeFilter = this.combineBboxAndFilter(featureType.geometryName, featureType.bbox, options.srsName, options.filter);\n        Object.assign(context, {\n          'geometryName': featureType.geometryName,\n          'filter': completeFilter\n        });\n        writeGetFeature(node, [featureType.name], [context]);\n      });\n    }\n    return node;\n  }\n\n  /**\n   * Create a bbox filter and combine it with another optional filter.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../extent.js\").Extent} extent Extent.\n   * @param {string} [srsName] SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @param {import(\"./filter/Filter.js\").default} [filter] Filter condition.\n   * @return {import(\"./filter/Filter.js\").default} The filter.\n   */\n  combineBboxAndFilter(geometryName, extent, srsName, filter) {\n    const bboxFilter = bboxFilterFn(geometryName, extent, srsName);\n    if (filter) {\n      // if bbox and filter are both set, combine the two into a single filter\n      return andFilterFn(filter, bboxFilter);\n    }\n    return bboxFilter;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const version = options.version ? options.version : this.version_;\n    const node = createElementNS(WFSNS[version], 'Transaction');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', SCHEMA_LOCATIONS[version]);\n    const request = createTransactionRequest(node, baseObj, version, options);\n    if (inserts) {\n      serializeTransactionRequest('Insert', inserts, objectStack, request);\n    }\n    if (updates) {\n      serializeTransactionRequest('Update', updates, objectStack, request);\n    }\n    if (deletes) {\n      serializeTransactionRequest('Delete', deletes, objectStack, request);\n    }\n    if (options.nativeElements) {\n      serializeTransactionRequest('Native', options.nativeElements, objectStack, request);\n    }\n    return node;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode( /** @type {Element} */n);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (!(n.childNodes.length === 0 || n.childNodes.length === 1 && n.firstChild.nodeType === 3)) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {*} baseObj Base object.\n * @param {string} version Version.\n * @param {WriteTransactionOptions} options Options.\n * @return {Object} Request object.\n */\nfunction createTransactionRequest(node, baseObj, version, options) {\n  const featurePrefix = options.featurePrefix ? options.featurePrefix : FEATURE_PREFIX;\n  let gmlVersion;\n  if (version === '1.0.0') {\n    gmlVersion = 2;\n  } else if (version === '1.1.0') {\n    gmlVersion = 3;\n  } else if (version === '2.0.0') {\n    gmlVersion = 3.2;\n  }\n  const obj = Object.assign({\n    node\n  }, {\n    version,\n    'featureNS': options.featureNS,\n    'featureType': options.featureType,\n    'featurePrefix': featurePrefix,\n    'gmlVersion': gmlVersion,\n    'hasZ': options.hasZ,\n    'srsName': options.srsName\n  }, baseObj);\n  return obj;\n}\n\n/**\n * @param {string} type Request type.\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @param {Element} request Transaction Request.\n */\nfunction serializeTransactionRequest(type, features, objectStack, request) {\n  pushSerializeAndPop(request, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory(type), features, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  },\n  'http://www.opengis.net/ogc/1.1': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    })\n  }\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Feature': fidParser\n  }\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else if (gmlVersion === 3) {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML32.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = OGCNS[version];\n  const filter = createElementNS(ns, 'Filter');\n  const child = createElementNS(ns, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */fid);\n  node.appendChild(filter);\n}\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @return {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.startsWith(prefix)) {\n    return featureType;\n  }\n  return prefix + featureType;\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 'Features must have an id set');\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 'Features must have an id set');\n  const version = context['version'];\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (value && typeof ( /** @type {?} */value.getSimplifiedGeometry) === 'function') {\n          name = geometryName;\n        }\n        values.push({\n          name: name,\n          value: value\n        });\n      }\n    }\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */{\n      version,\n      'gmlVersion': context['gmlVersion'],\n      node,\n      'hasZ': context['hasZ'],\n      'srsName': context['srsName']\n    }, TRANSACTION_SERIALIZERS, makeSimpleNodeFactory('Property'), values, objectStack);\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = WFSNS[version];\n  const tagName = version === '2.0.0' ? 'ValueReference' : 'Name';\n  const name = createElementNS(ns, tagName);\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(ns, 'Value');\n    node.appendChild(value);\n    if (pair.value && typeof ( /** @type {?} */pair.value.getSimplifiedGeometry) === 'function') {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else if (gmlVersion === 3) {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Query': makeChildAppender(writeQuery)\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  },\n  'http://www.opengis.net/fes/2.0': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Disjoint': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'ResourceId': makeChildAppender(writeResourceIdFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter)\n  }\n};\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  let typeNameAttr;\n  if (version === '2.0.0') {\n    typeNameAttr = 'typeNames';\n  } else {\n    typeNameAttr = 'typeName';\n  }\n  node.setAttribute(typeNameAttr, typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */\n  Object.assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, QUERY_SERIALIZERS, makeSimpleNodeFactory('PropertyName'), propertyNames, objectStack);\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(getFilterNS(version), 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  const context = /** @type {Object} */objectStack[objectStack.length - 1];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {\n    node\n  };\n  Object.assign(item, {\n    context\n  });\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(filter.getTagName()), [filter], objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n/**\n * @param {Element} node Element.\n * @param {import(\"./filter/ResourceId.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeResourceIdFilter(node, filter, objectStack) {\n  node.setAttribute('rid', /** @type {string} */filter.rid);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Spatial.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeSpatialFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/DWithin.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDWithinFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  writeSpatialFilter(node, filter, objectStack);\n  const distance = createElementNS(getFilterNS(version), 'Distance');\n  writeStringTextNode(distance, filter.distance.toString());\n  if (version === '2.0.0') {\n    distance.setAttribute('uom', filter.unit);\n  } else {\n    distance.setAttribute('units', filter.unit);\n  }\n  node.appendChild(distance);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n  node.appendChild(timePeriod);\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {\n    node\n  };\n  Object.assign(item, {\n    context\n  });\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {\n    node\n  };\n  Object.assign(item, {\n    context\n  });\n  const condition = filter.condition;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory(condition.getTagName()), [condition], objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.expression);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  writePropertyName(version, node, filter.propertyName);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  const ns = getFilterNS(version);\n  writePropertyName(version, node, filter.propertyName);\n  const lowerBoundary = createElementNS(ns, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);\n  const upperBoundary = createElementNS(ns, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */objectStack[objectStack.length - 1];\n  const context = parent['context'];\n  const version = context['version'];\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.pattern);\n}\n\n/**\n * @param {string} ns Namespace.\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeExpression(ns, tagName, node, value) {\n  const property = createElementNS(ns, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeLiteral(version, node, value) {\n  writeExpression(getFilterNS(version), 'Literal', node, value);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writePropertyName(version, node, value) {\n  if (version === '2.0.0') {\n    writeExpression(FESNS[version], 'ValueReference', node, value);\n  } else {\n    writeExpression(OGCNS[version], 'PropertyName', node, value);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {string} version WFS version. If not provided defaults to '1.1.0'\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter, version) {\n  version = version || '1.1.0';\n  const child = createElementNS(getFilterNS(version), 'Filter');\n  const context = {\n    node: child\n  };\n  Object.assign(context, {\n    'version': version,\n    'filter': filter\n  });\n  writeFilterCondition(child, filter, [context]);\n  return child;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */objectStack[objectStack.length - 1];\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */\n  Object.assign({}, context);\n  item.node = node;\n  pushSerializeAndPop(item, GETFEATURE_SERIALIZERS, makeSimpleNodeFactory('Query'), featureTypes, objectStack);\n}\nfunction getFilterNS(version) {\n  let ns;\n  if (version === '2.0.0') {\n    ns = FESNS[version];\n  } else {\n    ns = OGCNS[version];\n  }\n  return ns;\n}\nexport default WFS;","map":{"version":3,"names":["GML2","GML3","GML32","GMLBase","GMLNS","XMLFeature","XML_SCHEMA_INSTANCE_URI","createElementNS","isDocument","makeArrayPusher","makeChildAppender","makeObjectPropertySetter","makeSimpleNodeFactory","parse","parseNode","pushParseAndPop","pushSerializeAndPop","and","andFilterFn","bbox","bboxFilterFn","assert","get","getProjection","readNonNegativeIntegerString","readPositiveInteger","writeStringTextNode","FEATURE_COLLECTION_PARSERS","prototype","readExtentElement","readFeaturesInternal","TRANSACTION_SUMMARY_PARSERS","TRANSACTION_RESPONSE_PARSERS","readTransactionSummary","readInsertResults","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","writeFeature","writeUpdate","writeDelete","writeProperty","writeNative","FEATURE_PREFIX","XMLNS","OGCNS","WFSNS","FESNS","SCHEMA_LOCATIONS","GML_FORMATS","DEFAULT_VERSION","WFS","constructor","options","version_","version","featureType_","featureType","featureNS_","featureNS","gmlFormat_","gmlFormat","schemaLocation_","schemaLocation","getFeatureType","setFeatureType","readFeaturesFromNode","node","context","Object","assign","getReadOptions","objectStack","featuresNS","features","readTransactionResponse","source","undefined","doc","readTransactionResponseFromDocument","readTransactionResponseFromNode","readFeatureCollectionMetadata","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","firstChild","nextSibling","nodeType","Node","ELEMENT_NODE","result","value","getAttribute","writeGetFeature","setAttribute","handle","outputFormat","maxFeatures","String","resultType","startIndex","count","viewParams","setAttributeNS","srsName","featurePrefix","propertyNames","Array","isArray","featureTypes","filter","geometryName","combineBboxAndFilter","forEach","completeFilter","name","extent","bboxFilter","writeTransaction","inserts","updates","deletes","baseObj","gmlOptions","request","createTransactionRequest","serializeTransactionRequest","nativeElements","readProjectionFromDocument","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","length","readGeometryElement","pop","gmlVersion","obj","hasZ","type","OGC_FID_PARSERS","fidParser","INSERT_RESULTS_PARSERS","feature","child","appendChild","writeFeatureElement","writeOgcFidFilter","fid","ns","getTypeName","prefix","startsWith","getId","typeName","getGeometryName","keys","getKeys","values","i","ii","getSimplifiedGeometry","push","pair","tagName","writeGeometryElement","nativeElement","vendorId","safeToIgnore","GETFEATURE_SERIALIZERS","writeQuery","writeDuringFilter","writeLogicalFilter","writeNotFilter","writeBboxFilter","writeSpatialFilter","writeDWithinFilter","writeComparisonFilter","writeIsNullFilter","writeIsBetweenFilter","writeIsLikeFilter","writeResourceIdFilter","typeNameAttr","item","getFilterNS","writeFilterCondition","getTagName","parent","format","writePropertyName","rid","geometry","distance","toString","unit","writeExpression","propertyName","timePeriod","begin","writeTimeInstant","end","conditions","condition","matchCase","writeLiteral","expression","lowerBoundary","upperBoundary","wildCard","singleChar","escapeChar","pattern","property","time","timeInstant","timePosition","writeFilter"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/WFS.js"],"sourcesContent":["/**\n * @module ol/format/WFS\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GML32 from './GML32.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  isDocument,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeSimpleNodeFactory,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {and as andFilterFn, bbox as bboxFilterFn} from './filter.js';\nimport {assert} from '../asserts.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readNonNegativeIntegerString,\n  readPositiveInteger,\n  writeStringTextNode,\n} from './xsd.js';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readExtentElement,\n      'bounds',\n    ),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'member': makeArrayPusher(GMLBase.prototype.readFeaturesInternal),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'totalInserted': makeObjectPropertySetter(readPositiveInteger),\n    'totalUpdated': makeObjectPropertySetter(readPositiveInteger),\n    'totalDeleted': makeObjectPropertySetter(readPositiveInteger),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary',\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary',\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n};\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response.\n * Default is `ol/format/GML2` for WFS 1.0.0, `ol/format/GML3` for WFS 1.1.0 and `ol/format/GML32` for WFS 2.0.0.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n * @property {string} [version='1.1.0'] WFS version to use. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string|FeatureType>} featureTypes The feature type names or FeatureType objects to\n * define a unique bbox filter per feature type name (in this case, options `bbox` and `geometryName` are\n * ignored.).\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter. The `geometryName`\n * option must be set.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * e.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} FeatureType\n * @property {!string} name The feature type name.\n * @property {!import(\"../extent.js\").Extent} bbox Extent to use for the BBOX filter.\n * @property {!string} geometryName Geometry name to use in the BBOX filter.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0`, `1.1.0` or `2.0.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures NumberOfFeatures.\n * @property {import(\"../extent.js\").Extent} bounds Bounds.\n */\n\n/**\n * @typedef {Object} TransactionSummary\n * @property {number} totalDeleted TotalDeleted.\n * @property {number} totalInserted TotalInserted.\n * @property {number} totalUpdated TotalUpdated.\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {TransactionSummary} transactionSummary Transaction summary.\n * @property {Array<string>} insertIds InsertIds.\n */\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @type {Object<string, string>}\n */\nconst OGCNS = {\n  '2.0.0': 'http://www.opengis.net/ogc/1.1',\n  '1.1.0': 'http://www.opengis.net/ogc',\n  '1.0.0': 'http://www.opengis.net/ogc',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst WFSNS = {\n  '2.0.0': 'http://www.opengis.net/wfs/2.0',\n  '1.1.0': 'http://www.opengis.net/wfs',\n  '1.0.0': 'http://www.opengis.net/wfs',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst FESNS = {\n  '2.0.0': 'http://www.opengis.net/fes/2.0',\n  '1.1.0': 'http://www.opengis.net/fes',\n  '1.0.0': 'http://www.opengis.net/fes',\n};\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '2.0.0':\n    'http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd',\n  '1.1.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',\n};\n\n/**\n * @type {Object<string, object>}\n */\nconst GML_FORMATS = {\n  '2.0.0': GML32,\n  '1.1.0': GML3,\n  '1.0.0': GML2,\n};\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option to override the default.\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.version_ = options.version ? options.version : DEFAULT_VERSION;\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat\n      ? options.gmlFormat\n      : new GML_FORMATS[this.version_]();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation\n      ? options.schemaLocation\n      : SCHEMA_LOCATIONS[this.version_];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    Object.assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_,\n    });\n\n    Object.assign(context, this.getReadOptions(node, options ? options : {}));\n    const objectStack = [context];\n    let featuresNS;\n    if (this.version_ === '2.0.0') {\n      featuresNS = FEATURE_COLLECTION_PARSERS;\n    } else {\n      featuresNS = this.gmlFormat_.FEATURE_COLLECTION_PARSERS;\n    }\n    let features = pushParseAndPop(\n      [],\n      featuresNS,\n      node,\n      objectStack,\n      this.gmlFormat_,\n    );\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source),\n      );\n    }\n    return this.readTransactionResponseFromNode(\n      /** @type {Element} */ (source),\n    );\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    }\n    if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    }\n    if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source),\n      );\n    }\n    return this.readFeatureCollectionMetadataFromNode(\n      /** @type {Element} */ (source),\n    );\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n          /** @type {Element} */ (n),\n        );\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures'),\n    );\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS,\n      node,\n      [],\n      this.gmlFormat_,\n    );\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */ ({}),\n      TRANSACTION_RESPONSE_PARSERS,\n      node,\n      [],\n    );\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS[this.version_], 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', this.version_);\n    if (options.handle) {\n      node.setAttribute('handle', options.handle);\n    }\n    if (options.outputFormat) {\n      node.setAttribute('outputFormat', options.outputFormat);\n    }\n    if (options.maxFeatures !== undefined) {\n      node.setAttribute('maxFeatures', String(options.maxFeatures));\n    }\n    if (options.resultType) {\n      node.setAttribute('resultType', options.resultType);\n    }\n    if (options.startIndex !== undefined) {\n      node.setAttribute('startIndex', String(options.startIndex));\n    }\n    if (options.count !== undefined) {\n      node.setAttribute('count', String(options.count));\n    }\n    if (options.viewParams !== undefined) {\n      node.setAttribute('viewParams', options.viewParams);\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation_,\n    );\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node,\n    };\n    Object.assign(context, {\n      'version': this.version_,\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'propertyNames': options.propertyNames ? options.propertyNames : [],\n    });\n    assert(\n      Array.isArray(options.featureTypes),\n      '`options.featureTypes` must be an Array',\n    );\n    if (typeof options.featureTypes[0] === 'string') {\n      let filter = options.filter;\n      if (options.bbox) {\n        assert(\n          options.geometryName,\n          '`options.geometryName` must also be provided when `options.bbox` is set',\n        );\n        filter = this.combineBboxAndFilter(\n          options.geometryName,\n          options.bbox,\n          options.srsName,\n          filter,\n        );\n      }\n      Object.assign(context, {\n        'geometryName': options.geometryName,\n        'filter': filter,\n      });\n      writeGetFeature(\n        node,\n        /** @type {!Array<string>} */ (options.featureTypes),\n        [context],\n      );\n    } else {\n      // Write one query node per element in featuresType.\n      options.featureTypes.forEach((/** @type {FeatureType} */ featureType) => {\n        const completeFilter = this.combineBboxAndFilter(\n          featureType.geometryName,\n          featureType.bbox,\n          options.srsName,\n          options.filter,\n        );\n        Object.assign(context, {\n          'geometryName': featureType.geometryName,\n          'filter': completeFilter,\n        });\n        writeGetFeature(node, [featureType.name], [context]);\n      });\n    }\n    return node;\n  }\n\n  /**\n   * Create a bbox filter and combine it with another optional filter.\n   *\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../extent.js\").Extent} extent Extent.\n   * @param {string} [srsName] SRS name. No srsName attribute will be\n   *    set on geometries when this is not provided.\n   * @param {import(\"./filter/Filter.js\").default} [filter] Filter condition.\n   * @return {import(\"./filter/Filter.js\").default} The filter.\n   */\n  combineBboxAndFilter(geometryName, extent, srsName, filter) {\n    const bboxFilter = bboxFilterFn(geometryName, extent, srsName);\n    if (filter) {\n      // if bbox and filter are both set, combine the two into a single filter\n      return andFilterFn(filter, bboxFilter);\n    }\n    return bboxFilter;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const version = options.version ? options.version : this.version_;\n    const node = createElementNS(WFSNS[version], 'Transaction');\n\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      SCHEMA_LOCATIONS[version],\n    );\n\n    const request = createTransactionRequest(node, baseObj, version, options);\n    if (inserts) {\n      serializeTransactionRequest('Insert', inserts, objectStack, request);\n    }\n    if (updates) {\n      serializeTransactionRequest('Update', updates, objectStack, request);\n    }\n    if (deletes) {\n      serializeTransactionRequest('Delete', deletes, objectStack, request);\n    }\n    if (options.nativeElements) {\n      serializeTransactionRequest(\n        'Native',\n        options.nativeElements,\n        objectStack,\n        request,\n      );\n    }\n    return node;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (\n          !(\n            n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)\n          )\n        ) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {*} baseObj Base object.\n * @param {string} version Version.\n * @param {WriteTransactionOptions} options Options.\n * @return {Object} Request object.\n */\nfunction createTransactionRequest(node, baseObj, version, options) {\n  const featurePrefix = options.featurePrefix\n    ? options.featurePrefix\n    : FEATURE_PREFIX;\n  let gmlVersion;\n  if (version === '1.0.0') {\n    gmlVersion = 2;\n  } else if (version === '1.1.0') {\n    gmlVersion = 3;\n  } else if (version === '2.0.0') {\n    gmlVersion = 3.2;\n  }\n  const obj = Object.assign(\n    {node},\n    {\n      version,\n      'featureNS': options.featureNS,\n      'featureType': options.featureType,\n      'featurePrefix': featurePrefix,\n      'gmlVersion': gmlVersion,\n      'hasZ': options.hasZ,\n      'srsName': options.srsName,\n    },\n    baseObj,\n  );\n  return obj;\n}\n\n/**\n * @param {string} type Request type.\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {Array<*>} objectStack Object stack.\n * @param {Element} request Transaction Request.\n */\nfunction serializeTransactionRequest(type, features, objectStack, request) {\n  pushSerializeAndPop(\n    request,\n    TRANSACTION_SERIALIZERS,\n    makeSimpleNodeFactory(type),\n    features,\n    objectStack,\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n  'http://www.opengis.net/ogc/1.1': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser,\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Feature': fidParser,\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else if (gmlVersion === 3) {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML32.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = OGCNS[version];\n  const filter = createElementNS(ns, 'Filter');\n  const child = createElementNS(ns, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @return {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.startsWith(prefix)) {\n    return featureType;\n  }\n  return prefix + featureType;\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 'Features must have an id set');\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 'Features must have an id set');\n  const version = context['version'];\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (\n          value &&\n          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'\n        ) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */ ({\n        version,\n        'gmlVersion': context['gmlVersion'],\n        node,\n        'hasZ': context['hasZ'],\n        'srsName': context['srsName'],\n      }),\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Property'),\n      values,\n      objectStack,\n    );\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const version = context['version'];\n  const ns = WFSNS[version];\n  const tagName = version === '2.0.0' ? 'ValueReference' : 'Name';\n  const name = createElementNS(ns, tagName);\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(ns, 'Value');\n    node.appendChild(value);\n    if (\n      pair.value &&\n      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===\n        'function'\n    ) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else if (gmlVersion === 3) {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML32.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/wfs/2.0': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n  'http://www.opengis.net/fes/2.0': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeSpatialFilter),\n    'Disjoint': makeChildAppender(writeSpatialFilter),\n    'Intersects': makeChildAppender(writeSpatialFilter),\n    'ResourceId': makeChildAppender(writeResourceIdFilter),\n    'Within': makeChildAppender(writeSpatialFilter),\n    'DWithin': makeChildAppender(writeDWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const version = context['version'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  let typeNameAttr;\n  if (version === '2.0.0') {\n    typeNameAttr = 'typeNames';\n  } else {\n    typeNameAttr = 'typeName';\n  }\n  node.setAttribute(typeNameAttr, typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    Object.assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'),\n    propertyNames,\n    objectStack,\n  );\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(getFilterNS(version), 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter],\n    objectStack,\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n/**\n * @param {Element} node Element.\n * @param {import(\"./filter/ResourceId.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeResourceIdFilter(node, filter, objectStack) {\n  node.setAttribute('rid', /** @type {string} */ (filter.rid));\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Spatial.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeSpatialFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  parent['srsName'] = filter.srsName;\n  const format = GML_FORMATS[version];\n\n  writePropertyName(version, node, filter.geometryName);\n  format.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/DWithin.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDWithinFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writeSpatialFilter(node, filter, objectStack);\n  const distance = createElementNS(getFilterNS(version), 'Distance');\n  writeStringTextNode(distance, filter.distance.toString());\n  if (version === '2.0.0') {\n    distance.setAttribute('uom', filter.unit);\n  } else {\n    distance.setAttribute('units', filter.unit);\n  }\n  node.appendChild(distance);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n\n  writeExpression(FESNS[version], 'ValueReference', node, filter.propertyName);\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(\n      item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition],\n      objectStack,\n    );\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node};\n  Object.assign(item, {context});\n  const condition = filter.condition;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition],\n    objectStack,\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.expression);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  writePropertyName(version, node, filter.propertyName);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  const ns = getFilterNS(version);\n\n  writePropertyName(version, node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(ns, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeLiteral(version, lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(ns, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeLiteral(version, upperBoundary, '' + filter.upperBoundary);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  const parent = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const context = parent['context'];\n  const version = context['version'];\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writePropertyName(version, node, filter.propertyName);\n  writeLiteral(version, node, '' + filter.pattern);\n}\n\n/**\n * @param {string} ns Namespace.\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeExpression(ns, tagName, node, value) {\n  const property = createElementNS(ns, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeLiteral(version, node, value) {\n  writeExpression(getFilterNS(version), 'Literal', node, value);\n}\n\n/**\n * @param {string} version Version.\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writePropertyName(version, node, value) {\n  if (version === '2.0.0') {\n    writeExpression(FESNS[version], 'ValueReference', node, value);\n  } else {\n    writeExpression(OGCNS[version], 'PropertyName', node, value);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {string} version WFS version. If not provided defaults to '1.1.0'\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter, version) {\n  version = version || '1.1.0';\n  const child = createElementNS(getFilterNS(version), 'Filter');\n  const context = {\n    node: child,\n  };\n  Object.assign(context, {\n    'version': version,\n    'filter': filter,\n  });\n  writeFilterCondition(child, filter, [context]);\n  return child;\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (\n    Object.assign({}, context)\n  );\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'),\n    featureTypes,\n    objectStack,\n  );\n}\n\nfunction getFilterNS(version) {\n  let ns;\n  if (version === '2.0.0') {\n    ns = FESNS[version];\n  } else {\n    ns = OGCNS[version];\n  }\n  return ns;\n}\n\nexport default WFS;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}