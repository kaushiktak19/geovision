{"ast":null,"code":"/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, { GMLNS } from './GMLBase.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport { OBJECT_PROPERTY_NODE_FACTORY, XML_SCHEMA_INSTANCE_URI, createElementNS, getAllTextContent, makeArrayExtender, makeArrayPusher, makeChildAppender, makeReplacer, makeSimpleNodeFactory, parseNode, pushParseAndPop, pushSerializeAndPop } from '../xml.js';\nimport { createOrUpdate } from '../extent.js';\nimport { extend } from '../array.js';\nimport { get as getProjection } from '../proj.js';\nimport { readNonNegativeIntegerString, writeStringTextNode } from './xsd.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation = GMLNS + ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' + '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember'\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ = options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ = options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation ? options.schemaLocation : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop([], this.MULTICURVE_PARSERS, node, objectStack, this);\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop([], this.MULTISURFACE_PARSERS, node, objectStack, this);\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop([null], this.PATCHES_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop([null], this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array<Array<number>>} */\n      objectStack[objectStack.length - 1];\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(undefined, this.RING_PARSERS, node, objectStack, this);\n    if (flatLinearRing) {\n      const flatLinearRings = /** @type {Array<Array<number>>} */\n      objectStack[objectStack.length - 1];\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop([null], this.SURFACE_PARSERS, node, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop([null], this.CURVE_PARSERS, node, objectStack, this);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop([null], this.ENVELOPE_PARSERS, node, objectStack, this);\n    return createOrUpdate(flatCoordinates[1][0], flatCoordinates[1][1], flatCoordinates[2][0], flatCoordinates[2][1]);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while (m = re.exec(s)) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if ( /** @type {Element} */node.parentNode.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString( /** @type {Element} */node.parentNode.getAttribute('srsDimension'));\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords = axisOrientation.substr(0, 2) === 'en' ? point[0] + ' ' + point[1] : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    {\n      node: node\n    }, this.ENVELOPE_SERIALIZERS, OBJECT_PROPERTY_NODE_FACTORY, values, objectStack, keys, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(parentNode.namespaceURI, exteriorWritten !== undefined ? 'interior' : 'exterior');\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop({\n        node: node,\n        hasZ: hasZ,\n        srsName: srsName\n      }, this.RING_SERIALIZERS, this.RING_NODE_FACTORY_, rings, objectStack, undefined, this);\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'LineString' || node.nodeName === 'LineStringSegment') {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName,\n      surface: surface\n    }, this.SURFACEORPOLYGONMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, polygons, objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName\n    }, this.POINTMEMBER_SERIALIZERS, makeSimpleNodeFactory('pointMember'), points, objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop({\n      node: node,\n      hasZ: hasZ,\n      srsName: srsName,\n      curve: curve\n    }, this.LINESTRINGORCURVEMEMBER_SERIALIZERS, this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_, lines, objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */\n    objectStack[objectStack.length - 1];\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions( /** @type {import(\"../extent.js\").Extent} */geometry, context);\n    } else {\n      value = transformGeometryWithOptions( /** @type {import(\"../geom/Geometry.js\").default} */geometry, true, context);\n    }\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, this.GEOMETRY_SERIALIZERS, this.GEOMETRY_NODE_FACTORY_, [value], objectStack, undefined, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */fid);\n    }\n    const context = /** @type {Object} */objectStack[objectStack.length - 1];\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (key == geometryName || typeof ( /** @type {?} */value.getSimplifiedGeometry) === 'function') {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(this.writeGeometryElement, this);\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, context.serializers, makeSimpleNodeFactory(undefined, featureNS), values, objectStack, keys);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */objectStack[objectStack.length - 1];\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(this.writeFeatureElement, this);\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop( /** @type {import(\"../xml.js\").NodeStackItem} */\n    item, serializers, makeSimpleNodeFactory(featureType, featureNS), features, objectStack);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(this.namespace, MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]);\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */value.getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, options) {\n    options = this.adaptOptions(options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(XML_SCHEMA_INSTANCE_URI, 'xsi:schemaLocation', this.schemaLocation);\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(GML3.prototype.readLineStringSegment)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing)\n  }\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember),\n    'polygonMember': makeChildAppender(GML3.prototype.writeSurfaceOrPolygonMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(GML3.prototype.writeLineStringOrCurveMember),\n    'curveMember': makeChildAppender(GML3.prototype.writeLineStringOrCurveMember)\n  }\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(GML3.prototype.writeMultiSurfaceOrPolygon),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope)\n  }\n};\nexport default GML3;","map":{"version":3,"names":["GML2","GMLBase","GMLNS","LineString","MultiLineString","MultiPolygon","Polygon","OBJECT_PROPERTY_NODE_FACTORY","XML_SCHEMA_INSTANCE_URI","createElementNS","getAllTextContent","makeArrayExtender","makeArrayPusher","makeChildAppender","makeReplacer","makeSimpleNodeFactory","parseNode","pushParseAndPop","pushSerializeAndPop","createOrUpdate","extend","get","getProjection","readNonNegativeIntegerString","writeStringTextNode","transformExtentWithOptions","transformGeometryWithOptions","schemaLocation","MULTIGEOMETRY_TO_MEMBER_NODENAME","GML3","constructor","options","surface_","surface","undefined","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","hasZ","readMultiCurve","node","objectStack","lineStrings","MULTICURVE_PARSERS","multiLineString","readFlatCurveRing","flatCoordinates","i","ii","length","getFlatCoordinates","readMultiSurface","polygons","MULTISURFACE_PARSERS","curveMemberParser","CURVEMEMBER_PARSERS","surfaceMemberParser","SURFACEMEMBER_PARSERS","readPatch","PATCHES_PARSERS","readSegment","SEGMENTS_PARSERS","readPolygonPatch","FLAT_LINEAR_RINGS_PARSERS","readLineStringSegment","GEOMETRY_FLAT_COORDINATES_PARSERS","interiorParser","flatLinearRing","RING_PARSERS","flatLinearRings","push","exteriorParser","readSurface","SURFACE_PARSERS","ends","readCurve","CURVE_PARSERS","lineString","readEnvelope","ENVELOPE_PARSERS","readFlatPos","s","re","m","exec","parseFloat","substr","context","containerSrs","axisOrientation","proj","getAxisOrientation","y","x","len","readFlatPosList","replace","contextDimension","coords","split","dim","getAttribute","parentNode","z","writePos_","value","srsDimension","setAttribute","srsName","point","getCoordinates","getCoords_","writePosList_","points","parts","Array","join","writePoint","geometry","pos","namespaceURI","appendChild","writeEnvelope","extent","keys","values","ENVELOPE_SERIALIZERS","writeLinearRing","posList","RING_NODE_FACTORY_","nodeName","exteriorWritten","writeSurfaceOrPolygon","rings","getLinearRings","RING_SERIALIZERS","patches","writeSurfacePatches_","writeCurveOrLineString","segments","writeCurveSegments_","writeMultiSurfaceOrPolygon","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint","getPoints","POINTMEMBER_SERIALIZERS","writeMultiCurveOrLineString","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS","writeRing","ring","linearRing","writeSurfaceOrPolygonMember","polygon","child","GEOMETRY_NODE_FACTORY_","writePointMember","writeLineStringOrCurveMember","line","writeGeometryElement","item","Object","assign","isArray","GEOMETRY_SERIALIZERS","writeFeatureElement","feature","fid","getId","featureNS","geometryName","getGeometryName","serializers","hasProperties","properties","getProperties","key","getSimplifiedGeometry","writeFeatureMembers_","features","featureType","namespace","getType","writeGeometryNode","adaptOptions","geom","writeFeaturesNode","setAttributeNS","prototype","readFlatCoordinates","GEOMETRY_PARSERS","readPoint","readMultiPoint","readLineString","readMultiLineString","readLinearRing","readPolygon","readMultiPolygon","readFlatLinearRing","writeFeatures"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/GML3.js"],"sourcesContent":["/**\n * @module ol/format/GML3\n */\nimport GML2 from './GML2.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayExtender,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {createOrUpdate} from '../extent.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Polygon.\n   */\n  readFlatCurveRing(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    const flatCoordinates = [];\n    for (let i = 0, ii = lineStrings.length; i < ii; ++i) {\n      extend(flatCoordinates, lineStrings[i].getFlatCoordinates());\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop([], this.SEGMENTS_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1],\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension'),\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string} [srsName] Optional srsName\n   * @param {boolean} [hasZ] whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, srsName, hasZ) {\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ' ' + point[1]\n        : point[1] + ' ' + point[0];\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior',\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this,\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (\n      objectStack[objectStack.length - 1]\n    );\n    const item = Object.assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context,\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context,\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this,\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] =\n                makeChildAppender(writeStringTextNode);\n            }\n          }\n        }\n      }\n    }\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys,\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this,\n    );\n    const item = Object.assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack,\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName],\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string} [nodeName] Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (\n        value\n      ).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, options) {\n    options = this.adaptOptions(options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, options) {\n    options = this.adaptOptions(options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation,\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (options) {\n      Object.assign(context, options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n    'coordinates': makeReplacer(GML2.prototype.readFlatCoordinates),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeArrayExtender(\n      GML3.prototype.readLineStringSegment,\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n    'Ring': makeReplacer(GML3.prototype.readFlatCurveRing),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions} [options] Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember,\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember,\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember,\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString,\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon,\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}