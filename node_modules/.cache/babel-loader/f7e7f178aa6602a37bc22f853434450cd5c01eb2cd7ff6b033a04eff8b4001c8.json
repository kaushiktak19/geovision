{"ast":null,"code":"/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport { extend } from '../array.js';\nimport { getAllTextContent, getAttributeNS, makeArrayPusher, makeReplacer, parseNode, pushParseAndPop } from '../xml.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformExtentWithOptions, transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal)\n    };\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop([], this.FEATURE_COLLECTION_PARSERS, node, objectStack, this);\n    } else if (localName == 'featureMembers' || localName == 'featureMember' || localName == 'member') {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        featureType = [], featureNS = {};\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */node.childNodes[i];\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType) ? featureType : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':') ? featureTypes[i].split(':')[0] : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] = localName == 'featureMembers' ? makeArrayPusher(this.readFeatureElement, this) : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */objectStack[0];\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] = node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(null, this.GEOMETRY_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */objectStack[0];\n    const extent = /** @type {import(\"../extent.js\").Extent} */\n    this.readGeometryOrExtent(node, objectStack);\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */objectStack[0];\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */\n    this.readGeometryOrExtent(node, objectStack);\n    return geometry ? transformGeometryWithOptions(geometry, false, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (n.childNodes.length === 0 || n.childNodes.length === 1 && (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4)) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value = localName === 'boundedBy' ? this.readExtentElement(n, objectStack) : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n      const len = n.attributes.length;\n      if (len > 0 && !(value instanceof Geometry)) {\n        value = {\n          _content_: value\n        };\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    }\n    const feature = new Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    const fid = node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop([], this.MULTIPOINT_PARSERS, node, objectStack, this);\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop([], this.MULTILINESTRING_PARSERS, node, objectStack, this);\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop([], this.MULTIPOLYGON_PARSERS, node, objectStack, this);\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n    if (ring) {\n      return ring;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop([null], this.FLAT_LINEAR_RINGS_PARSERS, node, objectStack, this);\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(null, this.GEOMETRY_FLAT_COORDINATES_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [this.getReadOptions(node, options ? options : {})]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return getProjection(this.srsName ? this.srsName : node.firstElementChild.getAttribute('srsName'));\n  }\n}\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {}\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(GMLBase.prototype.lineStringMemberParser),\n    'lineStringMembers': makeArrayPusher(GMLBase.prototype.lineStringMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon)\n  }\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing)\n  }\n};\nexport default GMLBase;","map":{"version":3,"names":["Feature","Geometry","LineString","LinearRing","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","XMLFeature","extend","getAllTextContent","getAttributeNS","makeArrayPusher","makeReplacer","parseNode","pushParseAndPop","get","getProjection","transformExtentWithOptions","transformGeometryWithOptions","GMLNS","ONLY_WHITESPACE_RE","GMLBase","constructor","options","featureType","featureNS","srsName","schemaLocation","FEATURE_COLLECTION_PARSERS","namespace","readFeaturesInternal","supportedMediaTypes","node","objectStack","localName","features","context","prefix","defaultPrefix","childNodes","i","ii","length","child","nodeType","ft","nodeName","split","pop","includes","key","count","uri","namespaceURI","candidate","push","ns","parsersNS","featureTypes","Array","isArray","p","parsers","featurePrefix","readFeatureElement","undefined","readGeometryOrExtent","firstElementChild","getAttribute","GEOMETRY_PARSERS","readExtentElement","extent","readGeometryElement","geometry","readFeatureElementInternal","asFeature","geometryName","values","n","nextElementSibling","value","firstChild","test","len","attributes","_content_","attName","name","feature","setGeometryName","fid","setId","readPoint","flatCoordinates","readFlatCoordinatesFromNode","readMultiPoint","coordinates","MULTIPOINT_PARSERS","readMultiLineString","lineStrings","MULTILINESTRING_PARSERS","readMultiPolygon","polygons","MULTIPOLYGON_PARSERS","pointMemberParser","POINTMEMBER_PARSERS","lineStringMemberParser","LINESTRINGMEMBER_PARSERS","polygonMemberParser","POLYGONMEMBER_PARSERS","readLineString","lineString","readFlatLinearRing","ring","GEOMETRY_FLAT_COORDINATES_PARSERS","readLinearRing","readPolygon","flatLinearRings","FLAT_LINEAR_RINGS_PARSERS","ends","readGeometryFromNode","getReadOptions","readFeaturesFromNode","internalOptions","Object","assign","readProjectionFromNode","prototype","RING_PARSERS"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/GMLBase.js"],"sourcesContent":["/**\n * @module ol/format/GMLBase\n */\n// FIXME Envelopes should not be treated as geometries! readEnvelope_ is part\n// of GEOMETRY_PARSERS_ and methods using GEOMETRY_PARSERS_ do not expect\n// envelopes/extents, only geometries!\nimport Feature from '../Feature.js';\nimport Geometry from '../geom/Geometry.js';\nimport LineString from '../geom/LineString.js';\nimport LinearRing from '../geom/LinearRing.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport XMLFeature from './XMLFeature.js';\nimport {extend} from '../array.js';\nimport {\n  getAllTextContent,\n  getAttributeNS,\n  makeArrayPusher,\n  makeReplacer,\n  parseNode,\n  pushParseAndPop,\n} from '../xml.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n */\nexport const GMLNS = 'http://www.opengis.net/gml';\n\n/**\n * A regular expression that matches if a string only contains whitespace\n * characters. It will e.g. match `''`, `' '`, `'\\n'` etc.\n *\n * @const\n * @type {RegExp}\n */\nconst ONLY_WHITESPACE_RE = /^\\s*$/;\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] Feature\n * namespace. If not defined will be derived from GML. If multiple\n * feature types have been configured which come from different feature\n * namespaces, this will be an object with the keys being the prefixes used\n * in the entries of featureType array. The values of the object will be the\n * feature namespaces themselves. So for instance there might be a featureType\n * item `topp:states` in the `featureType` array and then there will be a key\n * `topp` in the featureNS object with value `http://www.openplans.org/topp`.\n * @property {Array<string>|string} [featureType] Feature type(s) to parse.\n * If multiple feature types need to be configured\n * which come from different feature namespaces, `featureNS` will be an object\n * with the keys being the prefixes used in the entries of featureType array.\n * The values of the object will be the feature namespaces themselves.\n * So for instance there might be a featureType item `topp:states` and then\n * there will be a key named `topp` in the featureNS object with value\n * `http://www.openplans.org/topp`.\n * @property {string} [srsName] srsName to use when writing geometries.\n * @property {boolean} [surface=false] Write gml:Surface instead of gml:Polygon\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [curve=false] Write gml:Curve instead of gml:LineString\n * elements. This also affects the elements in multi-part geometries.\n * @property {boolean} [multiCurve=true] Write gml:MultiCurve instead of gml:MultiLineString.\n * Since the latter is deprecated in GML 3.\n * @property {boolean} [multiSurface=true] Write gml:multiSurface instead of\n * gml:MultiPolygon. Since the latter is deprecated in GML 3.\n * @property {string} [schemaLocation] Optional schemaLocation to use when\n * writing out the GML, this will override the default provided.\n * @property {boolean} [hasZ=false] If coordinates have a Z value.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Feature base format for reading and writing data in the GML format.\n * This class cannot be instantiated, it contains only base content that\n * is shared with versioned format classes GML2 and GML3.\n *\n * @abstract\n * @api\n */\nclass GMLBase extends XMLFeature {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @protected\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType = options.featureType;\n\n    /**\n     * @protected\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS = options.featureNS;\n\n    /**\n     * @protected\n     * @type {string|undefined}\n     */\n    this.srsName = options.srsName;\n\n    /**\n     * @protected\n     * @type {string}\n     */\n    this.schemaLocation = '';\n\n    /**\n     * @type {Object<string, Object<string, Object>>}\n     */\n    this.FEATURE_COLLECTION_PARSERS = {};\n    this.FEATURE_COLLECTION_PARSERS[this.namespace] = {\n      'featureMember': makeArrayPusher(this.readFeaturesInternal),\n      'featureMembers': makeReplacer(this.readFeaturesInternal),\n    };\n\n    this.supportedMediaTypes = ['application/gml+xml'];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<Feature> | undefined} Features.\n   */\n  readFeaturesInternal(node, objectStack) {\n    const localName = node.localName;\n    let features = null;\n    if (localName == 'FeatureCollection') {\n      features = pushParseAndPop(\n        [],\n        this.FEATURE_COLLECTION_PARSERS,\n        node,\n        objectStack,\n        this,\n      );\n    } else if (\n      localName == 'featureMembers' ||\n      localName == 'featureMember' ||\n      localName == 'member'\n    ) {\n      const context = objectStack[0];\n      let featureType = context['featureType'];\n      let featureNS = context['featureNS'];\n      const prefix = 'p';\n      const defaultPrefix = 'p0';\n      if (!featureType && node.childNodes) {\n        (featureType = []), (featureNS = {});\n        for (let i = 0, ii = node.childNodes.length; i < ii; ++i) {\n          const child = /** @type {Element} */ (node.childNodes[i]);\n          if (child.nodeType === 1) {\n            const ft = child.nodeName.split(':').pop();\n            if (!featureType.includes(ft)) {\n              let key = '';\n              let count = 0;\n              const uri = child.namespaceURI;\n              for (const candidate in featureNS) {\n                if (featureNS[candidate] === uri) {\n                  key = candidate;\n                  break;\n                }\n                ++count;\n              }\n              if (!key) {\n                key = prefix + count;\n                featureNS[key] = uri;\n              }\n              featureType.push(key + ':' + ft);\n            }\n          }\n        }\n        if (localName != 'featureMember') {\n          // recheck featureType for each featureMember\n          context['featureType'] = featureType;\n          context['featureNS'] = featureNS;\n        }\n      }\n      if (typeof featureNS === 'string') {\n        const ns = featureNS;\n        featureNS = {};\n        featureNS[defaultPrefix] = ns;\n      }\n      /** @type {Object<string, Object<string, import(\"../xml.js\").Parser>>} */\n      const parsersNS = {};\n      const featureTypes = Array.isArray(featureType)\n        ? featureType\n        : [featureType];\n      for (const p in featureNS) {\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        for (let i = 0, ii = featureTypes.length; i < ii; ++i) {\n          const featurePrefix = featureTypes[i].includes(':')\n            ? featureTypes[i].split(':')[0]\n            : defaultPrefix;\n          if (featurePrefix === p) {\n            parsers[featureTypes[i].split(':').pop()] =\n              localName == 'featureMembers'\n                ? makeArrayPusher(this.readFeatureElement, this)\n                : makeReplacer(this.readFeatureElement, this);\n          }\n        }\n        parsersNS[featureNS[p]] = parsers;\n      }\n      if (localName == 'featureMember' || localName == 'member') {\n        features = pushParseAndPop(undefined, parsersNS, node, objectStack);\n      } else {\n        features = pushParseAndPop([], parsersNS, node, objectStack);\n      }\n    }\n    if (features === null) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readGeometryOrExtent(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    context['srsName'] = node.firstElementChild.getAttribute('srsName');\n    context['srsDimension'] =\n      node.firstElementChild.getAttribute('srsDimension');\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Geometry.\n   */\n  readExtentElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const extent = /** @type {import(\"../extent.js\").Extent} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return extent ? transformExtentWithOptions(extent, context) : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../geom/Geometry.js\").default|undefined} Geometry.\n   */\n  readGeometryElement(node, objectStack) {\n    const context = /** @type {Object} */ (objectStack[0]);\n    const geometry = /** @type {import(\"../geom/Geometry.js\").default} */ (\n      this.readGeometryOrExtent(node, objectStack)\n    );\n    return geometry\n      ? transformGeometryWithOptions(geometry, false, context)\n      : undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {boolean} asFeature whether result should be wrapped as a feature.\n   * @return {Feature|Object} Feature\n   */\n  readFeatureElementInternal(node, objectStack, asFeature) {\n    let geometryName;\n    const values = {};\n    for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n      let value;\n      const localName = n.localName;\n      // first, check if it is simple attribute\n      if (\n        n.childNodes.length === 0 ||\n        (n.childNodes.length === 1 &&\n          (n.firstChild.nodeType === 3 || n.firstChild.nodeType === 4))\n      ) {\n        value = getAllTextContent(n, false);\n        if (ONLY_WHITESPACE_RE.test(value)) {\n          value = undefined;\n        }\n      } else {\n        if (asFeature) {\n          //if feature, try it as a geometry or extent\n          value =\n            localName === 'boundedBy'\n              ? this.readExtentElement(n, objectStack)\n              : this.readGeometryElement(n, objectStack);\n        }\n        if (!value) {\n          //if not a geometry or not a feature, treat it as a complex attribute\n          value = this.readFeatureElementInternal(n, objectStack, false);\n        } else if (localName !== 'boundedBy') {\n          // boundedBy is an extent and must not be considered as a geometry\n          geometryName = localName;\n        }\n      }\n\n      const len = n.attributes.length;\n      if (len > 0 && !(value instanceof Geometry)) {\n        value = {_content_: value};\n        for (let i = 0; i < len; i++) {\n          const attName = n.attributes[i].name;\n          value[attName] = n.attributes[i].value;\n        }\n      }\n\n      if (values[localName]) {\n        if (!(values[localName] instanceof Array)) {\n          values[localName] = [values[localName]];\n        }\n        values[localName].push(value);\n      } else {\n        values[localName] = value;\n      }\n    }\n    if (!asFeature) {\n      return values;\n    }\n    const feature = new Feature(values);\n    if (geometryName) {\n      feature.setGeometryName(geometryName);\n    }\n    const fid =\n      node.getAttribute('fid') || getAttributeNS(node, this.namespace, 'id');\n    if (fid) {\n      feature.setId(fid);\n    }\n    return feature;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Feature} Feature.\n   */\n  readFeatureElement(node, objectStack) {\n    return this.readFeatureElementInternal(node, objectStack, true);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Point|undefined} Point.\n   */\n  readPoint(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new Point(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPoint|undefined} MultiPoint.\n   */\n  readMultiPoint(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const coordinates = pushParseAndPop(\n      [],\n      this.MULTIPOINT_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (coordinates) {\n      return new MultiPoint(coordinates);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiLineString(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTILINESTRING_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (lineStrings) {\n      return new MultiLineString(lineStrings);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiPolygon(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTIPOLYGON_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  pointMemberParser(node, objectStack) {\n    parseNode(this.POINTMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  lineStringMemberParser(node, objectStack) {\n    parseNode(this.LINESTRINGMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  polygonMemberParser(node, objectStack) {\n    parseNode(this.POLYGONMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readLineString(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, 'XYZ');\n      return lineString;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} LinearRing flat coordinates.\n   */\n  readFlatLinearRing(node, objectStack) {\n    const ring = pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (ring) {\n      return ring;\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LinearRing|undefined} LinearRing.\n   */\n  readLinearRing(node, objectStack) {\n    const flatCoordinates = this.readFlatCoordinatesFromNode(node, objectStack);\n    if (flatCoordinates) {\n      return new LinearRing(flatCoordinates, 'XYZ');\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readPolygon(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, 'XYZ', ends);\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>} Flat coordinates.\n   */\n  readFlatCoordinatesFromNode(node, objectStack) {\n    return pushParseAndPop(\n      null,\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this,\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @protected\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometryFromNode(node, options) {\n    const geometry = this.readGeometryElement(node, [\n      this.getReadOptions(node, options ? options : {}),\n    ]);\n    return geometry ? geometry : null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {\n      featureType: this.featureType,\n      featureNS: this.featureNS,\n    };\n    if (internalOptions) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    const features = this.readFeaturesInternal(node, [internalOptions]);\n    return features || [];\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    return getProjection(\n      this.srsName\n        ? this.srsName\n        : node.firstElementChild.getAttribute('srsName'),\n    );\n  }\n}\n\nGMLBase.prototype.namespace = GMLNS;\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {},\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOINT_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n    'pointMembers': makeArrayPusher(GMLBase.prototype.pointMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTILINESTRING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n    'lineStringMembers': makeArrayPusher(\n      GMLBase.prototype.lineStringMemberParser,\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.MULTIPOLYGON_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'polygonMember': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n    'polygonMembers': makeArrayPusher(GMLBase.prototype.polygonMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POINTMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeArrayPusher(GMLBase.prototype.readFlatCoordinatesFromNode),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.LINESTRINGMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.POLYGONMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGMLBase.prototype.RING_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LinearRing': makeReplacer(GMLBase.prototype.readFlatLinearRing),\n  },\n};\n\nexport default GMLBase;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}