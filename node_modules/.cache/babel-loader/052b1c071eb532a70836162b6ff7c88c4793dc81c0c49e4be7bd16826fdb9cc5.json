{"ast":null,"code":"/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {'barometric' | 'gps' | 'none'} IGCZ\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n */\n\n/**\n * @const\n * @type {RegExp}\n */\nconst B_RECORD_RE = /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTEDATE_RECORD_RE = /^HFDTEDATE:(\\d{2})(\\d{2})(\\d{2}),(\\d{2})/;\n\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nconst NEWLINE_RE = /\\r\\n|\\r|\\n/;\n\n/**\n * @typedef {Object} Options\n * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nclass IGC extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.lad_ = false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.lod_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ladStart_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ladStop_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lodStart_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lodStop_ = 0;\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const altitudeMode = this.altitudeMode_;\n    const lines = text.split(NEWLINE_RE);\n    /** @type {Object<string, string>} */\n    const properties = {};\n    const flatCoordinates = [];\n    let year = 2000;\n    let month = 0;\n    let day = 1;\n    let lastDateTime = -1;\n    let i, ii;\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      let m;\n      if (line.charAt(0) == 'B') {\n        m = B_RECORD_RE.exec(line);\n        if (m) {\n          const hour = parseInt(m[1], 10);\n          const minute = parseInt(m[2], 10);\n          const second = parseInt(m[3], 10);\n          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n          if (this.lad_) {\n            y += parseInt(line.slice(this.ladStart_, this.ladStop_), 10) / 60000 / 10 ** (this.ladStop_ - this.ladStart_);\n          }\n          if (m[6] == 'S') {\n            y = -y;\n          }\n          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n          if (this.lod_) {\n            x += parseInt(line.slice(this.lodStart_, this.lodStop_), 10) / 60000 / 10 ** (this.lodStop_ - this.lodStart_);\n          }\n          if (m[9] == 'W') {\n            x = -x;\n          }\n          flatCoordinates.push(x, y);\n          if (altitudeMode != 'none') {\n            let z;\n            if (altitudeMode == 'gps') {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == 'barometric') {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n            flatCoordinates.push(z);\n          }\n          let dateTime = Date.UTC(year, month, day, hour, minute, second);\n          // Detect UTC midnight wrap around.\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = HFDTEDATE_RECORD_RE.exec(line);\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = HFDTE_RECORD_RE.exec(line);\n          if (m) {\n            day = parseInt(m[1], 10);\n            month = parseInt(m[2], 10) - 1;\n            year = 2000 + parseInt(m[3], 10);\n          } else {\n            m = H_RECORD_RE.exec(line);\n            if (m) {\n              properties[m[1]] = m[2].trim();\n            }\n          }\n        }\n      } else if (line.charAt(0) == 'I') {\n        const numberAdds = parseInt(line.slice(1, 3), 10);\n        for (let i = 0; i < numberAdds; i++) {\n          const addCode = line.slice(7 + i * 7, 10 + i * 7);\n          if (addCode === 'LAD' || addCode === 'LOD') {\n            // in IGC format, columns are numbered from 1\n            const addStart = parseInt(line.slice(3 + i * 7, 5 + i * 7), 10) - 1;\n            const addStop = parseInt(line.slice(5 + i * 7, 7 + i * 7), 10);\n            if (addCode === 'LAD') {\n              this.lad_ = true;\n              this.ladStart_ = addStart;\n              this.ladStop_ = addStop;\n            } else if (addCode === 'LOD') {\n              this.lod_ = true;\n              this.lodStart_ = addStart;\n              this.lodStop_ = addStop;\n            }\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    const layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';\n    const lineString = new LineString(flatCoordinates, layout);\n    const feature = new Feature(transformGeometryWithOptions(lineString, false, options));\n    feature.setProperties(properties, true);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    if (feature) {\n      return [feature];\n    }\n    return [];\n  }\n}\nexport default IGC;","map":{"version":3,"names":["Feature","LineString","TextFeature","get","getProjection","transformGeometryWithOptions","B_RECORD_RE","H_RECORD_RE","HFDTE_RECORD_RE","HFDTEDATE_RECORD_RE","NEWLINE_RE","IGC","constructor","options","dataProjection","altitudeMode_","altitudeMode","lad_","lod_","ladStart_","ladStop_","lodStart_","lodStop_","readFeatureFromText","text","lines","split","properties","flatCoordinates","year","month","day","lastDateTime","i","ii","length","line","m","charAt","exec","hour","parseInt","minute","second","y","slice","x","push","z","dateTime","Date","UTC","trim","numberAdds","addCode","addStart","addStop","layout","lineString","feature","setProperties","readFeaturesFromText"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/IGC.js"],"sourcesContent":["/**\n * @module ol/format/IGC\n */\nimport Feature from '../Feature.js';\nimport LineString from '../geom/LineString.js';\nimport TextFeature from './TextFeature.js';\nimport {get as getProjection} from '../proj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {'barometric' | 'gps' | 'none'} IGCZ\n * IGC altitude/z. One of 'barometric', 'gps', 'none'.\n */\n\n/**\n * @const\n * @type {RegExp}\n */\nconst B_RECORD_RE =\n  /^B(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{5})([NS])(\\d{3})(\\d{5})([EW])([AV])(\\d{5})(\\d{5})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst H_RECORD_RE = /^H.([A-Z]{3}).*?:(.*)/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTE_RECORD_RE = /^HFDTE(\\d{2})(\\d{2})(\\d{2})/;\n\n/**\n * @const\n * @type {RegExp}\n */\nconst HFDTEDATE_RECORD_RE = /^HFDTEDATE:(\\d{2})(\\d{2})(\\d{2}),(\\d{2})/;\n\n/**\n * A regular expression matching the newline characters `\\r\\n`, `\\r` and `\\n`.\n *\n * @const\n * @type {RegExp}\n */\nconst NEWLINE_RE = /\\r\\n|\\r|\\n/;\n\n/**\n * @typedef {Object} Options\n * @property {IGCZ} [altitudeMode='none'] Altitude mode. Possible\n * values are `'barometric'`, `'gps'`, and `'none'`.\n */\n\n/**\n * @classdesc\n * Feature format for `*.igc` flight recording files.\n *\n * As IGC sources contain a single feature,\n * {@link module:ol/format/IGC~IGC#readFeatures} will return the feature in an\n * array\n *\n * @api\n */\nclass IGC extends TextFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection('EPSG:4326');\n\n    /**\n     * @private\n     * @type {IGCZ}\n     */\n    this.altitudeMode_ = options.altitudeMode ? options.altitudeMode : 'none';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.lad_ = false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.lod_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ladStart_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.ladStop_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lodStart_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lodStop_ = 0;\n  }\n\n  /**\n   * @protected\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   */\n  readFeatureFromText(text, options) {\n    const altitudeMode = this.altitudeMode_;\n    const lines = text.split(NEWLINE_RE);\n    /** @type {Object<string, string>} */\n    const properties = {};\n    const flatCoordinates = [];\n    let year = 2000;\n    let month = 0;\n    let day = 1;\n    let lastDateTime = -1;\n    let i, ii;\n    for (i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      let m;\n      if (line.charAt(0) == 'B') {\n        m = B_RECORD_RE.exec(line);\n        if (m) {\n          const hour = parseInt(m[1], 10);\n          const minute = parseInt(m[2], 10);\n          const second = parseInt(m[3], 10);\n          let y = parseInt(m[4], 10) + parseInt(m[5], 10) / 60000;\n          if (this.lad_) {\n            y +=\n              parseInt(line.slice(this.ladStart_, this.ladStop_), 10) /\n              60000 /\n              10 ** (this.ladStop_ - this.ladStart_);\n          }\n          if (m[6] == 'S') {\n            y = -y;\n          }\n          let x = parseInt(m[7], 10) + parseInt(m[8], 10) / 60000;\n          if (this.lod_) {\n            x +=\n              parseInt(line.slice(this.lodStart_, this.lodStop_), 10) /\n              60000 /\n              10 ** (this.lodStop_ - this.lodStart_);\n          }\n          if (m[9] == 'W') {\n            x = -x;\n          }\n          flatCoordinates.push(x, y);\n          if (altitudeMode != 'none') {\n            let z;\n            if (altitudeMode == 'gps') {\n              z = parseInt(m[11], 10);\n            } else if (altitudeMode == 'barometric') {\n              z = parseInt(m[12], 10);\n            } else {\n              z = 0;\n            }\n            flatCoordinates.push(z);\n          }\n          let dateTime = Date.UTC(year, month, day, hour, minute, second);\n          // Detect UTC midnight wrap around.\n          if (dateTime < lastDateTime) {\n            dateTime = Date.UTC(year, month, day + 1, hour, minute, second);\n          }\n          flatCoordinates.push(dateTime / 1000);\n          lastDateTime = dateTime;\n        }\n      } else if (line.charAt(0) == 'H') {\n        m = HFDTEDATE_RECORD_RE.exec(line);\n        if (m) {\n          day = parseInt(m[1], 10);\n          month = parseInt(m[2], 10) - 1;\n          year = 2000 + parseInt(m[3], 10);\n        } else {\n          m = HFDTE_RECORD_RE.exec(line);\n          if (m) {\n            day = parseInt(m[1], 10);\n            month = parseInt(m[2], 10) - 1;\n            year = 2000 + parseInt(m[3], 10);\n          } else {\n            m = H_RECORD_RE.exec(line);\n            if (m) {\n              properties[m[1]] = m[2].trim();\n            }\n          }\n        }\n      } else if (line.charAt(0) == 'I') {\n        const numberAdds = parseInt(line.slice(1, 3), 10);\n        for (let i = 0; i < numberAdds; i++) {\n          const addCode = line.slice(7 + i * 7, 10 + i * 7);\n          if (addCode === 'LAD' || addCode === 'LOD') {\n            // in IGC format, columns are numbered from 1\n            const addStart = parseInt(line.slice(3 + i * 7, 5 + i * 7), 10) - 1;\n            const addStop = parseInt(line.slice(5 + i * 7, 7 + i * 7), 10);\n            if (addCode === 'LAD') {\n              this.lad_ = true;\n              this.ladStart_ = addStart;\n              this.ladStop_ = addStop;\n            } else if (addCode === 'LOD') {\n              this.lod_ = true;\n              this.lodStart_ = addStart;\n              this.lodStop_ = addStop;\n            }\n          }\n        }\n      }\n    }\n    if (flatCoordinates.length === 0) {\n      return null;\n    }\n    const layout = altitudeMode == 'none' ? 'XYM' : 'XYZM';\n    const lineString = new LineString(flatCoordinates, layout);\n    const feature = new Feature(\n      transformGeometryWithOptions(lineString, false, options),\n    );\n    feature.setProperties(properties, true);\n    return feature;\n  }\n\n  /**\n   * @param {string} text Text.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromText(text, options) {\n    const feature = this.readFeatureFromText(text, options);\n    if (feature) {\n      return [feature];\n    }\n    return [];\n  }\n}\n\nexport default IGC;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}