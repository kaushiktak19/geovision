{"ast":null,"code":"/**\n * @module ol/format/WMSGetFeatureInfo\n */\nimport GML2 from './GML2.js';\nimport XMLFeature from './XMLFeature.js';\nimport { extend } from '../array.js';\nimport { makeArrayPusher, makeStructureNS, pushParseAndPop } from '../xml.js';\n\n/**\n * @typedef {Object} Options\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst featureIdentifier = '_feature';\n\n/**\n * @const\n * @type {string}\n */\nconst layerIdentifier = '_layer';\n\n/**\n * @classdesc\n * Format for reading WMSGetFeatureInfo format. It uses\n * {@link module:ol/format/GML2~GML2} to read features.\n *\n * @api\n */\nclass WMSGetFeatureInfo extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n\n    /**\n     * @private\n     * @type {GML2}\n     */\n    this.gmlFormat_ = new GML2();\n\n    /**\n     * @private\n     * @type {Array<string>|null}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n  }\n\n  /**\n   * @return {Array<string>|null} layers\n   */\n  getLayers() {\n    return this.layers_;\n  }\n\n  /**\n   * @param {Array<string>|null} layers Layers to parse.\n   */\n  setLayers(layers) {\n    this.layers_ = layers;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  readFeatures_(node, objectStack) {\n    node.setAttribute('namespaceURI', this.featureNS_);\n    const localName = node.localName;\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    let features = [];\n    if (node.childNodes.length === 0) {\n      return features;\n    }\n    if (localName == 'msGMLOutput') {\n      for (let i = 0, ii = node.childNodes.length; i < ii; i++) {\n        const layer = node.childNodes[i];\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n        const layerElement = /** @type {Element} */layer;\n        const context = objectStack[0];\n        const toRemove = layerIdentifier;\n        const layerName = layerElement.localName.replace(toRemove, '');\n        if (this.layers_ && !this.layers_.includes(layerName)) {\n          continue;\n        }\n        const featureType = layerName + featureIdentifier;\n        context['featureType'] = featureType;\n        context['featureNS'] = this.featureNS_;\n\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        parsers[featureType] = makeArrayPusher(this.gmlFormat_.readFeatureElement, this.gmlFormat_);\n        const parsersNS = makeStructureNS([context['featureNS'], null], parsers);\n        layerElement.setAttribute('namespaceURI', this.featureNS_);\n        const layerFeatures = pushParseAndPop([],\n        // @ts-ignore\n        parsersNS, layerElement, objectStack, this.gmlFormat_);\n        if (layerFeatures) {\n          extend(features, layerFeatures);\n        }\n      }\n    }\n    if (localName == 'FeatureCollection') {\n      const gmlFeatures = pushParseAndPop([], this.gmlFormat_.FEATURE_COLLECTION_PARSERS, node, [{}], this.gmlFormat_);\n      if (gmlFeatures) {\n        features = gmlFeatures;\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {};\n    if (options) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    return this.readFeatures_(node, [internalOptions]);\n  }\n}\nexport default WMSGetFeatureInfo;","map":{"version":3,"names":["GML2","XMLFeature","extend","makeArrayPusher","makeStructureNS","pushParseAndPop","featureIdentifier","layerIdentifier","WMSGetFeatureInfo","constructor","options","featureNS_","gmlFormat_","layers_","layers","getLayers","setLayers","readFeatures_","node","objectStack","setAttribute","localName","features","childNodes","length","i","ii","layer","nodeType","Node","ELEMENT_NODE","layerElement","context","toRemove","layerName","replace","includes","featureType","parsers","readFeatureElement","parsersNS","layerFeatures","gmlFeatures","FEATURE_COLLECTION_PARSERS","readFeaturesFromNode","internalOptions","Object","assign","getReadOptions"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/WMSGetFeatureInfo.js"],"sourcesContent":["/**\n * @module ol/format/WMSGetFeatureInfo\n */\nimport GML2 from './GML2.js';\nimport XMLFeature from './XMLFeature.js';\nimport {extend} from '../array.js';\nimport {makeArrayPusher, makeStructureNS, pushParseAndPop} from '../xml.js';\n\n/**\n * @typedef {Object} Options\n * @property {Array<string>} [layers] If set, only features of the given layers will be returned by the format when read.\n */\n\n/**\n * @const\n * @type {string}\n */\nconst featureIdentifier = '_feature';\n\n/**\n * @const\n * @type {string}\n */\nconst layerIdentifier = '_layer';\n\n/**\n * @classdesc\n * Format for reading WMSGetFeatureInfo format. It uses\n * {@link module:ol/format/GML2~GML2} to read features.\n *\n * @api\n */\nclass WMSGetFeatureInfo extends XMLFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.featureNS_ = 'http://mapserver.gis.umn.edu/mapserver';\n\n    /**\n     * @private\n     * @type {GML2}\n     */\n    this.gmlFormat_ = new GML2();\n\n    /**\n     * @private\n     * @type {Array<string>|null}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n  }\n\n  /**\n   * @return {Array<string>|null} layers\n   */\n  getLayers() {\n    return this.layers_;\n  }\n\n  /**\n   * @param {Array<string>|null} layers Layers to parse.\n   */\n  setLayers(layers) {\n    this.layers_ = layers;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @private\n   */\n  readFeatures_(node, objectStack) {\n    node.setAttribute('namespaceURI', this.featureNS_);\n    const localName = node.localName;\n    /** @type {Array<import(\"../Feature.js\").default>} */\n    let features = [];\n    if (node.childNodes.length === 0) {\n      return features;\n    }\n    if (localName == 'msGMLOutput') {\n      for (let i = 0, ii = node.childNodes.length; i < ii; i++) {\n        const layer = node.childNodes[i];\n        if (layer.nodeType !== Node.ELEMENT_NODE) {\n          continue;\n        }\n\n        const layerElement = /** @type {Element} */ (layer);\n        const context = objectStack[0];\n\n        const toRemove = layerIdentifier;\n        const layerName = layerElement.localName.replace(toRemove, '');\n\n        if (this.layers_ && !this.layers_.includes(layerName)) {\n          continue;\n        }\n\n        const featureType = layerName + featureIdentifier;\n\n        context['featureType'] = featureType;\n        context['featureNS'] = this.featureNS_;\n\n        /** @type {Object<string, import(\"../xml.js\").Parser>} */\n        const parsers = {};\n        parsers[featureType] = makeArrayPusher(\n          this.gmlFormat_.readFeatureElement,\n          this.gmlFormat_,\n        );\n        const parsersNS = makeStructureNS(\n          [context['featureNS'], null],\n          parsers,\n        );\n        layerElement.setAttribute('namespaceURI', this.featureNS_);\n        const layerFeatures = pushParseAndPop(\n          [],\n          // @ts-ignore\n          parsersNS,\n          layerElement,\n          objectStack,\n          this.gmlFormat_,\n        );\n        if (layerFeatures) {\n          extend(features, layerFeatures);\n        }\n      }\n    }\n    if (localName == 'FeatureCollection') {\n      const gmlFeatures = pushParseAndPop(\n        [],\n        this.gmlFormat_.FEATURE_COLLECTION_PARSERS,\n        node,\n        [{}],\n        this.gmlFormat_,\n      );\n      if (gmlFeatures) {\n        features = gmlFeatures;\n      }\n    }\n    return features;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, options) {\n    const internalOptions = {};\n    if (options) {\n      Object.assign(internalOptions, this.getReadOptions(node, options));\n    }\n    return this.readFeatures_(node, [internalOptions]);\n  }\n}\n\nexport default WMSGetFeatureInfo;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}