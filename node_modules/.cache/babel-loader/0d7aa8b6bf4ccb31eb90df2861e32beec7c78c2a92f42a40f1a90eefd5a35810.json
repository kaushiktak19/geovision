{"ast":null,"code":"/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport RenderFeature from '../render/Feature.js';\nimport { GeometryCollection, LineString, MultiLineString, MultiPoint, MultiPolygon, Point, Polygon } from '../geom.js';\nimport { abstract } from '../util.js';\nimport { equivalent as equivalentProjection, get as getProjection, getTransform, transformExtent } from '../proj.js';\nimport { linearRingsAreOriented, linearRingssAreOriented, orientLinearRings, orientLinearRingsArray } from '../geom/flat/orient.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/***\n * @template {Feature|RenderFeature} T\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\n */\n\n/***\n * @template {import(\"../Feature.js\").FeatureClass} T\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @template {import('../Feature.js').FeatureClass} [T=typeof import('../Feature.js').default]\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {T}\n     */\n    this.featureClass = /** @type {T} */Feature;\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection ? getProjection(options.dataProjection) : this.readProjection(source);\n      if (options.extent && dataProjection && dataProjection.getUnits() === 'tile-pixels') {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign({\n      dataProjection: this.dataProjection,\n      featureProjection: this.defaultFeatureProjection,\n      featureClass: this.featureClass\n    }, options);\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike|Array<import(\"../render/Feature.js\").default>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<import('../Feature.js').FeatureLike|FeatureClassToFeature<T>>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {Feature} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<Feature>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options ? getProjection(options.featureProjection) : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n  let transformed = geometry;\n  if (featureProjection && dataProjection && !equivalentProjection(featureProjection, dataProjection)) {\n    if (write) {\n      transformed = /** @type {T} */geometry.clone();\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (write && options && /** @type {WriteOptions} */options.decimals !== undefined) {\n    const power = Math.pow(10, /** @type {WriteOptions} */options.decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */geometry.clone();\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options ? getProjection(options.featureProjection) : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n  if (featureProjection && dataProjection && !equivalentProjection(featureProjection, dataProjection)) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon\n};\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  var _geometry$ends;\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry.map(geometry => createRenderFeature({\n      ...object,\n      geometry\n    })).flat();\n  }\n  const geometryType = geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(new RenderFeature(geometryType, geometryType === 'Polygon' ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride) : geometry.flatCoordinates, (_geometry$ends = geometry.ends) === null || _geometry$ends === void 0 ? void 0 : _geometry$ends.flat(), stride, object.properties || {}, object.id).enableSimplifyTransformed(), false, options);\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map(geometry => createGeometry(geometry, options));\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(new Geometry(object.flatCoordinates, object.layout, object.ends), false, options);\n}","map":{"version":3,"names":["Feature","RenderFeature","GeometryCollection","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","abstract","equivalent","equivalentProjection","get","getProjection","getTransform","transformExtent","linearRingsAreOriented","linearRingssAreOriented","orientLinearRings","orientLinearRingsArray","FeatureFormat","constructor","dataProjection","undefined","defaultFeatureProjection","featureClass","supportedMediaTypes","getReadOptions","source","options","readProjection","extent","getUnits","setWorldExtent","featureProjection","adaptOptions","Object","assign","getType","readFeature","readFeatures","readGeometry","writeFeature","feature","writeFeatures","features","writeGeometry","geometry","transformGeometryWithOptions","write","transformed","clone","fromProjection","toProjection","transform","applyTransform","decimals","power","Math","pow","coordinates","i","ii","length","round","transformExtentWithOptions","GeometryConstructor","orientFlatCoordinates","flatCoordinates","ends","stride","Array","isArray","slice","createRenderFeature","object","_geometry$ends","map","flat","geometryType","type","Error","layout","properties","id","enableSimplifyTransformed","createGeometry","geometries","Geometry"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/Feature.js"],"sourcesContent":["/**\n * @module ol/format/Feature\n */\nimport Feature from '../Feature.js';\nimport RenderFeature from '../render/Feature.js';\nimport {\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from '../geom.js';\nimport {abstract} from '../util.js';\nimport {\n  equivalent as equivalentProjection,\n  get as getProjection,\n  getTransform,\n  transformExtent,\n} from '../proj.js';\nimport {\n  linearRingsAreOriented,\n  linearRingssAreOriented,\n  orientLinearRings,\n  orientLinearRingsArray,\n} from '../geom/flat/orient.js';\n\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n\n/**\n * @typedef {'arraybuffer' | 'json' | 'text' | 'xml'} Type\n */\n\n/**\n * @typedef {Object} SimpleGeometryObject\n * @property {import('../geom/Geometry.js').Type} type Type.\n * @property {Array<number>} flatCoordinates Flat coordinates.\n * @property {Array<number>|Array<Array<number>>} [ends] Ends or endss.\n * @property {import('../geom/Geometry.js').GeometryLayout} [layout] Layout.\n */\n\n/**\n * @typedef {Array<GeometryObject>} GeometryCollectionObject\n */\n\n/**\n * @typedef {SimpleGeometryObject|GeometryCollectionObject} GeometryObject\n */\n\n/**\n * @typedef {Object} FeatureObject\n * @property {string|number} [id] Id.\n * @property {GeometryObject} [geometry] Geometry.\n * @property {Object<string, *>} [properties] Properties.\n */\n\n/***\n * @template {Feature|RenderFeature} T\n * @typedef {T extends RenderFeature ? typeof RenderFeature : typeof Feature} FeatureToFeatureClass\n */\n\n/***\n * @template {import(\"../Feature.js\").FeatureClass} T\n * @typedef {T[keyof T] extends RenderFeature ? RenderFeature : Feature} FeatureClassToFeature\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @template {import('../Feature.js').FeatureClass} [T=typeof import('../Feature.js').default]\n * @abstract\n * @api\n */\nclass FeatureFormat {\n  constructor() {\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.dataProjection = undefined;\n\n    /**\n     * @protected\n     * @type {import(\"../proj/Projection.js\").default|undefined}\n     */\n    this.defaultFeatureProjection = undefined;\n\n    /**\n     * @protected\n     * @type {T}\n     */\n    this.featureClass = /** @type {T} */ (Feature);\n\n    /**\n     * A list media types supported by the format in descending order of preference.\n     * @type {Array<string>}\n     */\n    this.supportedMediaTypes = null;\n  }\n\n  /**\n   * Adds the data projection to the read options.\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Options.\n   * @return {ReadOptions|undefined} Options.\n   * @protected\n   */\n  getReadOptions(source, options) {\n    if (options) {\n      let dataProjection = options.dataProjection\n        ? getProjection(options.dataProjection)\n        : this.readProjection(source);\n      if (\n        options.extent &&\n        dataProjection &&\n        dataProjection.getUnits() === 'tile-pixels'\n      ) {\n        dataProjection = getProjection(dataProjection);\n        dataProjection.setWorldExtent(options.extent);\n      }\n      options = {\n        dataProjection: dataProjection,\n        featureProjection: options.featureProjection,\n      };\n    }\n    return this.adaptOptions(options);\n  }\n\n  /**\n   * Sets the `dataProjection` on the options, if no `dataProjection`\n   * is set.\n   * @param {WriteOptions|ReadOptions|undefined} options\n   *     Options.\n   * @protected\n   * @return {WriteOptions|ReadOptions|undefined}\n   *     Updated options.\n   */\n  adaptOptions(options) {\n    return Object.assign(\n      {\n        dataProjection: this.dataProjection,\n        featureProjection: this.defaultFeatureProjection,\n        featureClass: this.featureClass,\n      },\n      options,\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Type} The format type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").FeatureLike|Array<import(\"../render/Feature.js\").default>} Feature.\n   */\n  readFeature(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @abstract\n   * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {Array<import('../Feature.js').FeatureLike|FeatureClassToFeature<T>>} Features.\n   */\n  readFeatures(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @param {ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   */\n  readGeometry(source, options) {\n    return abstract();\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @abstract\n   * @param {Document|Element|Object|string} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   */\n  readProjection(source) {\n    return abstract();\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @abstract\n   * @param {Feature} feature Feature.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeature(feature, options) {\n    return abstract();\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @abstract\n   * @param {Array<Feature>} features Features.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeFeatures(features, options) {\n    return abstract();\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @abstract\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   */\n  writeGeometry(geometry, options) {\n    return abstract();\n  }\n}\n\nexport default FeatureFormat;\n\n/**\n * @template {import(\"../geom/Geometry.js\").default|RenderFeature} T\n * @param {T} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {T} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  let transformed = geometry;\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    if (write) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    const fromProjection = write ? featureProjection : dataProjection;\n    const toProjection = write ? dataProjection : featureProjection;\n    if (fromProjection.getUnits() === 'tile-pixels') {\n      transformed.transform(fromProjection, toProjection);\n    } else {\n      transformed.applyTransform(getTransform(fromProjection, toProjection));\n    }\n  }\n  if (\n    write &&\n    options &&\n    /** @type {WriteOptions} */ (options).decimals !== undefined\n  ) {\n    const power = Math.pow(10, /** @type {WriteOptions} */ (options).decimals);\n    // if decimals option on write, round each coordinate appropriately\n    /**\n     * @param {Array<number>} coordinates Coordinates.\n     * @return {Array<number>} Transformed coordinates.\n     */\n    const transform = function (coordinates) {\n      for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n        coordinates[i] = Math.round(coordinates[i] * power) / power;\n      }\n      return coordinates;\n    };\n    if (transformed === geometry) {\n      transformed = /** @type {T} */ (geometry.clone());\n    }\n    transformed.applyTransform(transform);\n  }\n  return transformed;\n}\n\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, options) {\n  const featureProjection = options\n    ? getProjection(options.featureProjection)\n    : null;\n  const dataProjection = options ? getProjection(options.dataProjection) : null;\n\n  if (\n    featureProjection &&\n    dataProjection &&\n    !equivalentProjection(featureProjection, dataProjection)\n  ) {\n    return transformExtent(extent, dataProjection, featureProjection);\n  }\n  return extent;\n}\n\nconst GeometryConstructor = {\n  Point: Point,\n  LineString: LineString,\n  Polygon: Polygon,\n  MultiPoint: MultiPoint,\n  MultiLineString: MultiLineString,\n  MultiPolygon: MultiPolygon,\n};\n\nfunction orientFlatCoordinates(flatCoordinates, ends, stride) {\n  if (Array.isArray(ends[0])) {\n    // MultiPolagon\n    if (!linearRingssAreOriented(flatCoordinates, 0, ends, stride)) {\n      flatCoordinates = flatCoordinates.slice();\n      orientLinearRingsArray(flatCoordinates, 0, ends, stride);\n    }\n    return flatCoordinates;\n  }\n  if (!linearRingsAreOriented(flatCoordinates, 0, ends, stride)) {\n    flatCoordinates = flatCoordinates.slice();\n    orientLinearRings(flatCoordinates, 0, ends, stride);\n  }\n  return flatCoordinates;\n}\n\n/**\n * @param {FeatureObject} object Feature object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {RenderFeature|Array<RenderFeature>} Render feature.\n */\nexport function createRenderFeature(object, options) {\n  const geometry = object.geometry;\n  if (!geometry) {\n    return [];\n  }\n  if (Array.isArray(geometry)) {\n    return geometry\n      .map((geometry) => createRenderFeature({...object, geometry}))\n      .flat();\n  }\n\n  const geometryType =\n    geometry.type === 'MultiPolygon' ? 'Polygon' : geometry.type;\n  if (geometryType === 'GeometryCollection' || geometryType === 'Circle') {\n    throw new Error('Unsupported geometry type: ' + geometryType);\n  }\n\n  const stride = geometry.layout.length;\n  return transformGeometryWithOptions(\n    new RenderFeature(\n      geometryType,\n      geometryType === 'Polygon'\n        ? orientFlatCoordinates(geometry.flatCoordinates, geometry.ends, stride)\n        : geometry.flatCoordinates,\n      geometry.ends?.flat(),\n      stride,\n      object.properties || {},\n      object.id,\n    ).enableSimplifyTransformed(),\n    false,\n    options,\n  );\n}\n\n/**\n * @param {GeometryObject|null} object Geometry object.\n * @param {WriteOptions|ReadOptions} [options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nexport function createGeometry(object, options) {\n  if (!object) {\n    return null;\n  }\n  if (Array.isArray(object)) {\n    const geometries = object.map((geometry) =>\n      createGeometry(geometry, options),\n    );\n    return new GeometryCollection(geometries);\n  }\n  const Geometry = GeometryConstructor[object.type];\n  return transformGeometryWithOptions(\n    new Geometry(object.flatCoordinates, object.layout, object.ends),\n    false,\n    options,\n  );\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,OAAOA,OAAO,MAAM,eAAe;AACnC,OAAOC,aAAa,MAAM,sBAAsB;AAChD,SACEC,kBAAkB,EAClBC,UAAU,EACVC,eAAe,EACfC,UAAU,EACVC,YAAY,EACZC,KAAK,EACLC,OAAO,QACF,YAAY;AACnB,SAAQC,QAAQ,QAAO,YAAY;AACnC,SACEC,UAAU,IAAIC,oBAAoB,EAClCC,GAAG,IAAIC,aAAa,EACpBC,YAAY,EACZC,eAAe,QACV,YAAY;AACnB,SACEC,sBAAsB,EACtBC,uBAAuB,EACvBC,iBAAiB,EACjBC,sBAAsB,QACjB,wBAAwB;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,aAAa,CAAC;EAClBC,WAAWA,CAAA,EAAG;IACZ;AACJ;AACA;AACA;IACI,IAAI,CAACC,cAAc,GAAGC,SAAS;;IAE/B;AACJ;AACA;AACA;IACI,IAAI,CAACC,wBAAwB,GAAGD,SAAS;;IAEzC;AACJ;AACA;AACA;IACI,IAAI,CAACE,YAAY,GAAG,gBAAkBzB,OAAQ;;IAE9C;AACJ;AACA;AACA;IACI,IAAI,CAAC0B,mBAAmB,GAAG,IAAI;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEC,cAAcA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAC9B,IAAIA,OAAO,EAAE;MACX,IAAIP,cAAc,GAAGO,OAAO,CAACP,cAAc,GACvCT,aAAa,CAA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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}