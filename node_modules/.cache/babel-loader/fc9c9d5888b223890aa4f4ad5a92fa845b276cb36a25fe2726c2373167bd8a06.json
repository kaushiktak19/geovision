{"ast":null,"code":"/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, { transformGeometryWithOptions } from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n   MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17\n};\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    /** @private */\n    this.view_ = view;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pos_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isLittleEndian_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasZ_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasM_ = false;\n\n    /**\n     * @type {number|null}\n     * @private\n     */\n    this.srid_ = null;\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32((this.pos_ += 4) - 4, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64((this.pos_ += 8) - 8, isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_);\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ = Boolean(wkbType & 0x80000000) || wkbTypeThousandth === 1 || wkbTypeThousandth === 3;\n    const hasM = Boolean(wkbType & 0x40000000) || wkbTypeThousandth === 2 || wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */\n    ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('');\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n      default:\n        throw new Error('Unsupported WKB geometry type ' + typeId + ' is found');\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.LINE_STRING);\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point( /** @type {import('../coordinate.js').Coordinate} */result, this.layout_);\n      case WKBGeometryType.LINE_STRING:\n        return new LineString( /** @type {Array<import('../coordinate.js').Coordinate>} */result, this.layout_);\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon( /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n        result, this.layout_);\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint( /** @type {Array<import('../coordinate.js').Coordinate>} */result, this.layout_);\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString( /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */\n        result, this.layout_);\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon( /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */\n        result, this.layout_);\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection( /** @type {Array<import('../geom/Geometry.js').default>} */result);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\nclass WkbWriter {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = Object.assign({\n      X: 0,\n      Y: 0,\n      Z: 0,\n      M: 0\n    }, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = Object.assign.apply(null, layout.split('').map((axis, idx) => ({\n      [axis]: coords[idx]\n    })));\n    for (const axis of this.layout_) {\n      this.writeDouble(axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.includes('Z')) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.includes('M')) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} [layout] layout\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n   */\n  findMinimumLayout(geom) {\n    let layout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'XYZM';\n    /**\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} a A\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} b B\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n      if (a === 'XYZM') {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === 'XYZM') {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return 'XY';\n    };\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== 'XY'; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    /**\n     * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n     */\n    const wkblut = {\n      Point: WKBGeometryType.POINT,\n      LineString: WKBGeometryType.LINE_STRING,\n      Polygon: WKBGeometryType.POLYGON,\n      MultiPoint: WKBGeometryType.MULTI_POINT,\n      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n      MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n    this.writeWkbHeader(typeId, srid);\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        Point: this.writePoint,\n        LineString: this.writeLineString,\n        Polygon: this.writePolygon,\n        MultiPoint: this.writeMultiPoint,\n        MultiLineString: this.writeMultiLineString,\n        MultiPolygon: this.writeMultiPolygon\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n    let pos = 0;\n    this.writeQueue_.forEach(item => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n      pos += item[0];\n    });\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n    this.splitCollection = Boolean(options.splitCollection);\n    this.viewCache_ = null;\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return this.hex_ ? 'text' : 'arraybuffer';\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return new Feature({\n      geometry: this.readGeometry(source, options)\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map(geometry => new Feature({\n      geometry\n    }));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    options = this.getReadOptions(source, options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n    return reader.getSrid() && getProjection('EPSG:' + reader.getSrid()) || undefined;\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return this.writeGeometry(feature.getGeometry(), options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return this.writeGeometry(new GeometryCollection(features.map(f => f.getGeometry())), options);\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    options = this.adaptOptions(options);\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_\n      }\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection = options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.startsWith('EPSG:')) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n    writer.writeGeometry(transformGeometryWithOptions(geometry, true, options), srid);\n    const buffer = writer.getBuffer();\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values()).map(x => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase()).join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  }\n  if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  }\n  if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  }\n  return null;\n}\nexport default WKB;","map":{"version":3,"names":["Feature","FeatureFormat","transformGeometryWithOptions","GeometryCollection","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","get","getProjection","SimpleGeometry","WKBGeometryType","POINT","LINE_STRING","POLYGON","MULTI_POINT","MULTI_LINE_STRING","MULTI_POLYGON","GEOMETRY_COLLECTION","POLYHEDRAL_SURFACE","TIN","TRIANGLE","WkbReader","constructor","view","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","byteOrder","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","call","readGeometry","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","Object","assign","X","Y","Z","M","nodata","writeUint8","value","writeUint32","writeDouble","writePoint","coordsObj","apply","split","map","axis","idx","writeLineString","length","writePolygon","writeWkbHeader","includes","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","arguments","GeometryLayout_min","a","b","getLayout","geoms","getGeometriesArray","wkblut","geomType","getType","writerLUT","getCoordinates","getBuffer","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","WKB","options","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","readFeature","source","geometry","readFeatures","getDataView","getReadOptions","readProjection","writeFeature","feature","getGeometry","writeFeatures","features","f","adaptOptions","writer","dataProjection","code","getCode","startsWith","substring","encodeHexString","Uint8Array","Array","from","values","x","toString","toUpperCase","decodeHexString","text","parseInt","substr","isView","byteOffset"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/WKB.js"],"sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    /** @private */\n    this.view_ = view;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pos_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isLittleEndian_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasZ_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasM_ = false;\n\n    /**\n     * @type {number|null}\n     * @private\n     */\n    this.srid_ = null;\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_,\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_,\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */ (\n      ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('')\n    );\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found',\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING,\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_,\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_,\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_,\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_,\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_,\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_,\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result),\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = Object.assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = Object.assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]})),\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis],\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.includes('Z')) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.includes('M')) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} [layout] layout\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = 'XYZM') {\n    /**\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} a A\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} b B\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} minimum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === 'XYZM') {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === 'XYZM') {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return 'XY';\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== 'XY'; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    /**\n     * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n     */\n    const wkblut = {\n      Point: WKBGeometryType.POINT,\n      LineString: WKBGeometryType.LINE_STRING,\n      Polygon: WKBGeometryType.POLYGON,\n      MultiPoint: WKBGeometryType.MULTI_POINT,\n      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n      MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        Point: this.writePoint,\n        LineString: this.writeLineString,\n        Polygon: this.writePolygon,\n        MultiPoint: this.writeMultiPoint,\n        MultiLineString: this.writeMultiLineString,\n        MultiPolygon: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return this.hex_ ? 'text' : 'arraybuffer';\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return new Feature({\n      geometry: this.readGeometry(source, options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    options = this.getReadOptions(source, options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return this.writeGeometry(feature.getGeometry(), options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      options,\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    options = this.adaptOptions(options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.startsWith('EPSG:')) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid,\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  }\n  if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  }\n  if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  }\n  return null;\n}\n\nexport default WKB;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}