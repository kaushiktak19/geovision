{"ast":null,"code":"/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nclass TopoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.layerName_ = options.layerName;\n\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    if (object.type == 'Topology') {\n      const topoJSONTopology = /** @type {TopoJSONTopology} */object;\n      let transform,\n        scale = null,\n        translate = null;\n      if (topoJSONTopology['transform']) {\n        transform = topoJSONTopology['transform'];\n        scale = transform['scale'];\n        translate = transform['translate'];\n      }\n      const arcs = topoJSONTopology['arcs'];\n      if (transform) {\n        transformArcs(arcs, scale, translate);\n      }\n      /** @type {Array<Feature>} */\n      const features = [];\n      const topoJSONFeatures = topoJSONTopology['objects'];\n      const property = this.layerName_;\n      let feature;\n      for (const objectName in topoJSONFeatures) {\n        if (this.layers_ && !this.layers_.includes(objectName)) {\n          continue;\n        }\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature = /** @type {TopoJSONGeometryCollection} */\n          topoJSONFeatures[objectName];\n          features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, options));\n        } else {\n          feature = /** @type {TopoJSONGeometry} */\n          topoJSONFeatures[objectName];\n          features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, options));\n        }\n      }\n      return features;\n    }\n    return [];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return this.dataProjection;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nconst GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry\n};\n\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  const coordinates = [];\n  let index;\n  for (let i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n    if (index >= 0) {\n      // forward arc\n      const arc = arcs[index];\n      for (let j = 0, jj = arc.length; j < jj; ++j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    } else {\n      // reverse arc\n      const arc = arcs[~index];\n      for (let j = arc.length - 1; j >= 0; --j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    }\n  }\n  return coordinates;\n}\n\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n  return new Point(coordinates);\n}\n\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n  return new MultiPoint(coordinates);\n}\n\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n  const coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new MultiLineString(coordinates);\n}\n\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new Polygon(coordinates);\n}\n\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    const polyArray = object['arcs'][i];\n    const ringCoords = [];\n    for (let j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n    coordinates[i] = ringCoords;\n  }\n  return new MultiPolygon(coordinates);\n}\n\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, options) {\n  const geometries = collection['geometries'];\n  const features = [];\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, options);\n  }\n  return features;\n}\n\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(object, arcs, scale, translate, property, name, options) {\n  let geometry = null;\n  const type = object.type;\n  if (type) {\n    const geometryReader = GEOMETRY_READERS[type];\n    if (type === 'Point' || type === 'MultiPoint') {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    geometry = transformGeometryWithOptions(geometry, false, options);\n  }\n  const feature = new Feature({\n    geometry: geometry\n  });\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n  let properties = object.properties;\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n    properties[property] = name;\n  }\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n  return feature;\n}\n\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n  for (let i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n  let x = 0;\n  let y = 0;\n  for (let i = 0, ii = arc.length; i < ii; ++i) {\n    const vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\nexport default TopoJSON;","map":{"version":3,"names":["Feature","JSONFeature","LineString","MultiLineString","MultiPoint","MultiPolygon","Point","Polygon","get","getProjection","transformGeometryWithOptions","TopoJSON","constructor","options","layerName_","layerName","layers_","layers","dataProjection","readFeaturesFromObject","object","type","topoJSONTopology","transform","scale","translate","arcs","transformArcs","features","topoJSONFeatures","property","feature","objectName","includes","push","apply","readFeaturesFromGeometryCollection","readFeatureFromGeometry","readProjectionFromObject","GEOMETRY_READERS","readPointGeometry","readLineStringGeometry","readPolygonGeometry","readMultiPointGeometry","readMultiLineStringGeometry","readMultiPolygonGeometry","concatenateArcs","indices","coordinates","index","i","ii","length","pop","arc","j","jj","slice","transformVertex","polyArray","ringCoords","collection","name","geometries","geometry","geometryReader","id","undefined","setId","properties","setProperties","transformArc","x","y","vertex"],"sources":["C:/Users/Asus/Desktop/population-density-map/node_modules/ol/format/TopoJSON.js"],"sourcesContent":["/**\n * @module ol/format/TopoJSON\n */\nimport Feature from '../Feature.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\nimport {transformGeometryWithOptions} from './Feature.js';\n\n/**\n * @typedef {import(\"topojson-specification\").Topology} TopoJSONTopology\n * @typedef {import(\"topojson-specification\").GeometryCollection} TopoJSONGeometryCollection\n * @typedef {import(\"topojson-specification\").GeometryObject} TopoJSONGeometry\n * @typedef {import(\"topojson-specification\").Point} TopoJSONPoint\n * @typedef {import(\"topojson-specification\").MultiPoint} TopoJSONMultiPoint\n * @typedef {import(\"topojson-specification\").LineString} TopoJSONLineString\n * @typedef {import(\"topojson-specification\").MultiLineString} TopoJSONMultiLineString\n * @typedef {import(\"topojson-specification\").Polygon} TopoJSONPolygon\n * @typedef {import(\"topojson-specification\").MultiPolygon} TopoJSONMultiPolygon\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {string} [layerName] Set the name of the TopoJSON topology\n * `objects`'s children as feature property with the specified name. This means\n * that when set to `'layer'`, a topology like\n * ```\n * {\n *   \"type\": \"Topology\",\n *   \"objects\": {\n *     \"example\": {\n *       \"type\": \"GeometryCollection\",\n *       \"geometries\": []\n *     }\n *   }\n * }\n * ```\n * will result in features that have a property `'layer'` set to `'example'`.\n * When not set, no property will be added to features.\n * @property {Array<string>} [layers] Names of the TopoJSON topology's\n * `objects`'s children to read features from.  If not provided, features will\n * be read from all children.\n */\n\n/**\n * @classdesc\n * Feature format for reading data in the TopoJSON format.\n *\n * @api\n */\nclass TopoJSON extends JSONFeature {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {string|undefined}\n     */\n    this.layerName_ = options.layerName;\n\n    /**\n     * @private\n     * @type {?Array<string>}\n     */\n    this.layers_ = options.layers ? options.layers : null;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.dataProjection = getProjection(\n      options.dataProjection ? options.dataProjection : 'EPSG:4326',\n    );\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @protected\n   * @return {Array<Feature>} Features.\n   */\n  readFeaturesFromObject(object, options) {\n    if (object.type == 'Topology') {\n      const topoJSONTopology = /** @type {TopoJSONTopology} */ (object);\n      let transform,\n        scale = null,\n        translate = null;\n      if (topoJSONTopology['transform']) {\n        transform = topoJSONTopology['transform'];\n        scale = transform['scale'];\n        translate = transform['translate'];\n      }\n      const arcs = topoJSONTopology['arcs'];\n      if (transform) {\n        transformArcs(arcs, scale, translate);\n      }\n      /** @type {Array<Feature>} */\n      const features = [];\n      const topoJSONFeatures = topoJSONTopology['objects'];\n      const property = this.layerName_;\n      let feature;\n      for (const objectName in topoJSONFeatures) {\n        if (this.layers_ && !this.layers_.includes(objectName)) {\n          continue;\n        }\n        if (topoJSONFeatures[objectName].type === 'GeometryCollection') {\n          feature = /** @type {TopoJSONGeometryCollection} */ (\n            topoJSONFeatures[objectName]\n          );\n          features.push.apply(\n            features,\n            readFeaturesFromGeometryCollection(\n              feature,\n              arcs,\n              scale,\n              translate,\n              property,\n              objectName,\n              options,\n            ),\n          );\n        } else {\n          feature = /** @type {TopoJSONGeometry} */ (\n            topoJSONFeatures[objectName]\n          );\n          features.push(\n            readFeatureFromGeometry(\n              feature,\n              arcs,\n              scale,\n              translate,\n              property,\n              objectName,\n              options,\n            ),\n          );\n        }\n      }\n      return features;\n    }\n    return [];\n  }\n\n  /**\n   * @param {Object} object Object.\n   * @protected\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromObject(object) {\n    return this.dataProjection;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import(\"../geom/Geometry.js\").default>}\n */\nconst GEOMETRY_READERS = {\n  'Point': readPointGeometry,\n  'LineString': readLineStringGeometry,\n  'Polygon': readPolygonGeometry,\n  'MultiPoint': readMultiPointGeometry,\n  'MultiLineString': readMultiLineStringGeometry,\n  'MultiPolygon': readMultiPolygonGeometry,\n};\n\n/**\n * Concatenate arcs into a coordinate array.\n * @param {Array<number>} indices Indices of arcs to concatenate.  Negative\n *     values indicate arcs need to be reversed.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs (already\n *     transformed).\n * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates array.\n */\nfunction concatenateArcs(indices, arcs) {\n  /** @type {Array<import(\"../coordinate.js\").Coordinate>} */\n  const coordinates = [];\n  let index;\n  for (let i = 0, ii = indices.length; i < ii; ++i) {\n    index = indices[i];\n    if (i > 0) {\n      // splicing together arcs, discard last point\n      coordinates.pop();\n    }\n    if (index >= 0) {\n      // forward arc\n      const arc = arcs[index];\n      for (let j = 0, jj = arc.length; j < jj; ++j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    } else {\n      // reverse arc\n      const arc = arcs[~index];\n      for (let j = arc.length - 1; j >= 0; --j) {\n        coordinates.push(arc[j].slice(0));\n      }\n    }\n  }\n  return coordinates;\n}\n\n/**\n * Create a point from a TopoJSON geometry object.\n *\n * @param {TopoJSONPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {Point} Geometry.\n */\nfunction readPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    transformVertex(coordinates, scale, translate);\n  }\n  return new Point(coordinates);\n}\n\n/**\n * Create a multi-point from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPoint} object TopoJSON object.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @return {MultiPoint} Geometry.\n */\nfunction readMultiPointGeometry(object, scale, translate) {\n  const coordinates = object['coordinates'];\n  if (scale && translate) {\n    for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n      transformVertex(coordinates[i], scale, translate);\n    }\n  }\n  return new MultiPoint(coordinates);\n}\n\n/**\n * Create a linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {LineString} Geometry.\n */\nfunction readLineStringGeometry(object, arcs) {\n  const coordinates = concatenateArcs(object['arcs'], arcs);\n  return new LineString(coordinates);\n}\n\n/**\n * Create a multi-linestring from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiLineString} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiLineString} Geometry.\n */\nfunction readMultiLineStringGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new MultiLineString(coordinates);\n}\n\n/**\n * Create a polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {Polygon} Geometry.\n */\nfunction readPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    coordinates[i] = concatenateArcs(object['arcs'][i], arcs);\n  }\n  return new Polygon(coordinates);\n}\n\n/**\n * Create a multi-polygon from a TopoJSON geometry object.\n *\n * @param {TopoJSONMultiPolygon} object TopoJSON object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @return {MultiPolygon} Geometry.\n */\nfunction readMultiPolygonGeometry(object, arcs) {\n  const coordinates = [];\n  for (let i = 0, ii = object['arcs'].length; i < ii; ++i) {\n    // for each polygon\n    const polyArray = object['arcs'][i];\n    const ringCoords = [];\n    for (let j = 0, jj = polyArray.length; j < jj; ++j) {\n      // for each ring\n      ringCoords[j] = concatenateArcs(polyArray[j], arcs);\n    }\n    coordinates[i] = ringCoords;\n  }\n  return new MultiPolygon(coordinates);\n}\n\n/**\n * Create features from a TopoJSON GeometryCollection object.\n *\n * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry\n *     object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Array<Feature>} Array of features.\n */\nfunction readFeaturesFromGeometryCollection(\n  collection,\n  arcs,\n  scale,\n  translate,\n  property,\n  name,\n  options,\n) {\n  const geometries = collection['geometries'];\n  const features = [];\n  for (let i = 0, ii = geometries.length; i < ii; ++i) {\n    features[i] = readFeatureFromGeometry(\n      geometries[i],\n      arcs,\n      scale,\n      translate,\n      property,\n      name,\n      options,\n    );\n  }\n  return features;\n}\n\n/**\n * Create a feature from a TopoJSON geometry object.\n *\n * @param {TopoJSONGeometry} object TopoJSON geometry object.\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n * @param {string|undefined} property Property to set the `GeometryCollection`'s parent\n *     object to.\n * @param {string} name Name of the `Topology`'s child object.\n * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n * @return {Feature} Feature.\n */\nfunction readFeatureFromGeometry(\n  object,\n  arcs,\n  scale,\n  translate,\n  property,\n  name,\n  options,\n) {\n  let geometry = null;\n  const type = object.type;\n  if (type) {\n    const geometryReader = GEOMETRY_READERS[type];\n    if (type === 'Point' || type === 'MultiPoint') {\n      geometry = geometryReader(object, scale, translate);\n    } else {\n      geometry = geometryReader(object, arcs);\n    }\n    geometry = transformGeometryWithOptions(geometry, false, options);\n  }\n  const feature = new Feature({geometry: geometry});\n  if (object.id !== undefined) {\n    feature.setId(object.id);\n  }\n  let properties = object.properties;\n  if (property) {\n    if (!properties) {\n      properties = {};\n    }\n    properties[property] = name;\n  }\n  if (properties) {\n    feature.setProperties(properties, true);\n  }\n  return feature;\n}\n\n/**\n * Apply a linear transform to array of arcs.  The provided array of arcs is\n * modified in place.\n *\n * @param {Array<Array<import(\"../coordinate.js\").Coordinate>>} arcs Array of arcs.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArcs(arcs, scale, translate) {\n  for (let i = 0, ii = arcs.length; i < ii; ++i) {\n    transformArc(arcs[i], scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to an arc.  The provided arc is modified in place.\n *\n * @param {Array<import(\"../coordinate.js\").Coordinate>} arc Arc.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformArc(arc, scale, translate) {\n  let x = 0;\n  let y = 0;\n  for (let i = 0, ii = arc.length; i < ii; ++i) {\n    const vertex = arc[i];\n    x += vertex[0];\n    y += vertex[1];\n    vertex[0] = x;\n    vertex[1] = y;\n    transformVertex(vertex, scale, translate);\n  }\n}\n\n/**\n * Apply a linear transform to a vertex.  The provided vertex is modified in\n * place.\n *\n * @param {import(\"../coordinate.js\").Coordinate} vertex Vertex.\n * @param {Array<number>} scale Scale for each dimension.\n * @param {Array<number>} translate Translation for each dimension.\n */\nfunction transformVertex(vertex, scale, translate) {\n  vertex[0] = vertex[0] * scale[0] + translate[0];\n  vertex[1] = vertex[1] * scale[1] + translate[1];\n}\n\nexport default TopoJSON;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}